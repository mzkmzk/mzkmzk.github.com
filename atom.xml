<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[K]]></title>
  <link href="http://mzkmzk.github.io/atom.xml" rel="self"/>
  <link href="http://mzkmzk.github.io/"/>
  <updated>2015-10-25T19:03:18+08:00</updated>
  <id>http://mzkmzk.github.io/</id>
  <author>
    <name><![CDATA[K]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[疯狂Html+CSS+JS 中HTML5总结]]></title>
    <link href="http://mzkmzk.github.io/blog/2015/10/24/amazeing-html5/"/>
    <updated>2015-10-24T11:37:40+08:00</updated>
    <id>http://mzkmzk.github.io/blog/2015/10/24/amazeing-html5</id>
    <content type="html"><![CDATA[<!--more-->


<h1>0总结</h1>

<h1>1. HTML5简介</h1>

<p>HTML:Hyper Text Markup Language.(How To Make Love - -.)</p>

<p>标记H5.</p>

<pre><code>&lt;!DOCTYPE html&gt;
</code></pre>

<p>作者的愤怒.</p>

<pre><code>不要再&lt;html&gt;和&lt;head&gt;、&lt;/head&gt;和&lt;body&gt;还有&lt;/body&gt;和&lt;/html&gt;插任何内容.      
</code></pre>

<p>验证HTML是否符合规范<a href="http://validator.w3.org/">http://validator.w3.org/</a>.</p>

<h1>2. HTML5常用标签和属性.</h1>

<h2>2.1 HTML常用属性</h2>

<h3>2.1.1文本格式化元素</h3>

<ol>
<li><code>&lt;i&gt;:</code> 斜体.</li>
<li><code>&lt;em&gt;:</code> 强调文本.</li>
<li><code>&lt;strong&gt;|&lt;b&gt;:</code> 粗体.</li>
<li><code>&lt;small&gt;:</code> 小号字体.</li>
<li><code>&lt;sup&gt;:</code> 上标</li>
<li><code>&lt;sub&gt;:</code> 下标</li>
<li><code>&lt;bdo&gt;:</code> 文本方向 设定属性dir为ltr/rtl(反着来)</li>
</ol>


<h3>2.1.2 语义相关元素</h3>

<ol>
<li><code>&lt;abbr&gt;:</code> 表示缩写,可定义title,表示全写,鼠标移上去会显示一次title.</li>
<li><code>&lt;address&gt;:</code> 表示地址,会斜体显示.</li>
<li><code>&lt;blockquote&gt;:</code> 表示定义引用很长的文本,会缩进显示,属性有cite指定该文应用的url.</li>
<li><code>&lt;q&gt;:</code> 定义短的引用文本.</li>
<li><code>&lt;cite&gt;:</code> 表示作品(书,电影,歌曲).</li>
<li><code>&lt;code&gt;:</code> 表示代码.</li>
<li><code>&lt;dfn&gt;:</code> 定义专业术语,一般会粗体/斜体显示.</li>
<li><code>&lt;del&gt;</code>: 表示删除的文本,一般会中画线显示.</li>
<li><p><code>&lt;ins&gt;:</code> 定义文档插入的文本,一般会下画线显示.</p>

<p> del和ins结合使用有文档修订的效果,这两个属性都有cite定义一个url解释删除/插入的原因,datetime表示删除/插入的时间.</p></li>
<li><p><code>&lt;pre&gt;:</code> 表示元素内已经预格式化了,该标签内的空格 回车 tab和其他格式的字符都会比保留下来.</p></li>
<li><code>&lt;samp&gt;:</code> 用于定义示范文本内容.</li>
<li><code>&lt;var&gt;:</code> 定义变量,一般斜体显示.</li>
</ol>


<h3>2.1.3 超链接和描点</h3>

<p>a标签属性</p>

<ol>
<li><p>href: 关联资源.</p>

<p> 语法规则<code>scheme://host.domain:port/path/filename</code></p>

<p> scheme(因特网服务类型): 常见有https http file ftp.还有</p>

<pre><code> 1. news: 访问新闻组上的文件.

 2. telnet: 访问Telnet连接.

 3. gopher: 访问远程Gopher服务器上的文件.

 4. mailto: 发送邮件
</code></pre>

<p> host: 指定此域中的主机,HTTP默认主机为www.</p></li>
<li><p>target: 如何显示关联资源</p>

<p> 2.1 _self: 自身.</p>

<p> 2.2 _blank: 新窗口.</p>

<p> 2.3 _top: 顶层框架 一般用于含有iframe等标签的时候使用.</p>

<p> 2.4 _parent: 父层显示.</p></li>
<li><p>media: 指定媒体类型(HTML5新增).</p></li>
<li>name: 命名描点.<code>&lt;a name="K"&gt;</code>.</li>
</ol>


<h3>2.1.4 列表相关元素</h3>

<ol>
<li><code>&lt;ul&gt;:</code> 无序列表.</li>
<li><p><code>&lt;ol&gt;:</code> 有序列表.</p>

<p> 2.1 start: 起始数字 1/A等.</p>

<p> 2.2 reversed: 反着排序.</p></li>
<li><p><code>&lt;li&gt;:</code> 列表项.</p></li>
<li><code>&lt;dl&gt;:</code> 定义列表.</li>
<li><code>&lt;dt&gt;:</code> 标题列表项.</li>
<li><code>&lt;dd&gt;:</code> 定义普通列表项.</li>
</ol>


<h3>2.1.5 图像相关属性</h3>

<p>img新增usemap属性.</p>

<ol>
<li><code>&lt;map&gt;:</code> 定义图片映射,包含多个<code>&lt;area&gt;</code>.</li>
<li><p><code>&lt;area&gt;:</code> 定义图片映射区域.特殊属性有</p>

<p> 2.1 shape: 默认为rect 还有circle和ploy属性.</p>

<p> 2.2 coords: 多个坐标,确定区域位置.</p>

<p> 2.3 href: 链接资源.</p>

<p> 2.4 alt: 提供图片信息.</p>

<p> 2.5 target.</p>

<p> 2.6 media.</p></li>
</ol>


<p>例子:</p>

<pre><code>&lt;img usemap="#test" .../&gt;

&lt;map name="test" id="test"&gt;
    &lt;area shape="cicle" coords="57,55,25" href...&gt;
    &lt;area shape="poloy" coords="188,28,185,50,200,74,244,72,246,51 ..."&gt;
&lt;/map&gt;  
</code></pre>

<h3>2.1.6 表格相关属性</h3>

<ol>
<li><code>&lt;caption&gt;:</code> 定义表格标题,智能包含文本 图片 超链接 文本格式元素 和表单控件.</li>
<li><code>&lt;colgroup&gt;:</code> 此标签智能包含在<code>&lt;table&gt;/&lt;colgroup&gt;</code>中,用来包含多个<code>&lt;col&gt;</code></li>
<li><code>&lt;col&gt;</code>: 用于指定一列或多列的样式.span属性控制控制几列.</li>
<li><code>&lt;thead&gt;:</code> 定义表格头.</li>
<li><code>&lt;tbody&gt;:</code> 定义表格体智能直接包含<code>&lt;tr&gt;</code>.</li>
<li><code>&lt;tfoot&gt;:</code> 定义表格腿.</li>
<li><code>&lt;tr&gt;</code>: 一行</li>
<li><code>&lt;th&gt;:</code> 定义页眉单元格.</li>
<li><p><code>&lt;td&gt;:</code>单元格,属性有:</p>

<p> 9.1 colspan: 单元格夸几列</p>

<p> 9.2 rowspan: 单元格夸几行</p></li>
</ol>


<p>例子</p>

<pre><code>&lt;!-- 书名列宽为160px 作者和价格列宽度为100px --&gt;
&lt;table&gt;
    &lt;caption&gt;标题&lt;/caption&gt;
    &lt;colgroup&gt;
        &lt;col style="width :160px"&gt;
        &lt;col span="2" style="width:100px"&gt;
    &lt;/colgroup&gt; 
    &lt;thead&gt;
        &lt;tr&gt;
            &lt;th&gt;书名&lt;/th&gt;
            &lt;th&gt;作者&lt;/th&gt;
            &lt;th&gt;价格&lt;/th&gt;
        &lt;/tr&gt;
    &lt;/thead&gt;
    &lt;tr&gt;
        &lt;td&gt;程序员把妹&lt;td/&gt;
        &lt;td&gt;K&lt;td/&gt;
        &lt;td&gt;1024&lt;td/&gt;
    &lt;/tr&gt;
    ...
    &lt;tfoot&gt;
        &lt;tr&gt;
            &lt;td&gt;现总计: 2本图书&lt;/td&gt;
        &lt;/tr&gt;
    &lt;/tfoot&gt;
</code></pre>

<h3>2.1.7 HTML5新增通用属性</h3>

<ol>
<li>contentEditable属性: 此值为true,组件可随意编辑.可继承.</li>
<li>isContetnEditable属性: 若处于可编辑状态,返回true.</li>
<li>designMode: 默认为off 设为on时,真个页面都可编辑(和在body设置contentEditable为true类似).</li>
<li>spellcheck: 当true时,用户输入的内容会进行单词拼接检查.</li>
<li>hidden: true/false,其实不建议用,样式还是给CSS控制吧.</li>
</ol>


<h2>2.2 HTML5 新增常用元素</h2>

<h3>2.2.1 文档结构元素</h3>

<p>此类元素其实只负责分块,其实无实际作用.只是友好提示程序员这是一块内容.</p>

<ol>
<li><code>&lt;article&gt;:</code> 用于展示一个整体内容,一篇文章 一条回复等.</li>
<li><code>&lt;nav&gt;:</code> 导航栏(边导航,页面导,底部导)标签.</li>
<li><code>&lt;header&gt;:</code> 页面顶部.</li>
<li><code>&lt;hgroup&gt;:</code> 定义多个标题时</li>
<li><code>&lt;section&gt;:</code> 内容分块.可设置cite属性.</li>
<li><code>&lt;aside&gt;:</code> 专门用于定义当前页面的附属信息,一般用作侧边栏.一般放在<code>&lt;footer&gt;</code>之前.</li>
<li><code>&lt;figure&gt;:</code> 用于一块图片区域,可包含一个<code>&lt;figcaption&gt;</code></li>
<li><code>&lt;figcaption&gt;:</code> 作为图片区域的标题.</li>
<li><code>&lt;footer&gt;</code>: 底部.</li>
</ol>


<h3>2.2.2 语义相关元素</h3>

<ol>
<li><code>&lt;mark&gt;:</code> 重点关注内容</li>
<li><code>&lt;time&gt;:</code> 指定时间,里面应该包含一个<code>datetime</code>属性指定符合<code>yyyy-MM-ddTHH:mm</code>格式的时间</li>
<li><code>&lt;details&gt;:</code>  用于展示某个主题的时间,可包含<code>&lt;summary&gt;</code>使用.</li>
<li><code>&lt;summary&gt;:</code> 作为details的摘要元素.</li>
</ol>


<h3>2.2.3 特殊功能的元素</h3>

<ol>
<li><p><code>&lt;meter&gt;:</code>用于表示一个已知最大值和最小值的计数仪表,属性皆可浮点</p>

<p> 1.1 value: 当前值.</p>

<p> 1.2 min: 最小值.</p>

<p> 1.3 max: 最大值.</p>

<p> 1.4 low: 指定范围的最小值.</p>

<p> 1.5 high: 指定范围的最小值.</p>

<p> 1.6 optimum: 指定有效范围的最佳值,若大于high,表示当前值越大越好,若小于low,则表示当前值越少越好.</p></li>
<li><p><code>&lt;progress&gt;:</code> 用于表示一个进度条.</p>

<p> 2.1 max: 进度条完成时的值.</p>

<p> 2.2 value: 当前值.</p></li>
</ol>


<h2>2.3 HTML5 头部和元数据</h2>

<ol>
<li><p><code>&lt;base&gt;:</code> 相对地址取的是此base的href,而非url.绝好放在head的头元素.</p>

<p> 1.1 href: 指定相对地址</p>

<p> 1.2 target: 默认打开链接方式</p></li>
<li><p><code>&lt;meta&gt;:</code> 指定页面元信息.</p>

<p> 2.1 name: 可为:</p>

<pre><code> 2.1.1 author: 作者        
 2.1.2 description: 简述 
 2.1.3 keywords: 关键词 
 2.1.4 generator: 说明生成工具,如`Microsoft FrontPage 4.0`等
     &lt;meta name=”generator” Content=”PCDATA|FrontPage|”&gt;

 2.1.5 revised: 定义网页版本
     &lt;meta name=”revised” content=”David, 2008/8/8/” /&gt;

 2.1.6 robots: 给机器人(搜索引擎)做登陆参考,可同时设多个属性逗号分隔

     2.1.6.1 all：默认,文件将被检索，且页面上的链接可以被查询(和 "index,follow"作用一样) 
     2.1.6.2 none：文件将不被检索，且页面上的链接不可以被查询(和 “noindex, no follow” 起相同作用)
     2.1.6.3 index：文件将被检索；（让robot/spider登录）
     2.1.6.4 follow：页面上的链接可以被查询；
     2.1.6.5 noindex：文件将不被检索
     2.1.6.6 nofollow：页面上的链接不可以被查询

 2.1.7 others: - -....   
 2.1.8 viewport: 优化移动浏览器显示,。如果不是响应式网站，不要使用initial-scale或者禁用缩放。大部分4.7-5寸设备的viewport宽设为360px；5.5寸设备设为400px；iphone6设为375px；ipone6 plus设为414px。

     &lt;meta name="viewport" content="width=device-width, initial-scale=1.0,maximum-scale=1.0, user-scalable=no"/&gt;
     &lt;!-- `width=device-width` 会导致 iPhone 5 添加到主屏后以 WebApp 全屏模式打开页面时出现黑边  --&gt;

     width：宽度（数值 / device-width）（范围从200 到10,000，默认为980 像素）
     height：高度（数值 / device-height）（范围从223 到10,000）
     initial-scale：初始的缩放比例 （范围从&gt;0 到10）
     minimum-scale：允许用户缩放到的最小比例
     maximum-scale：允许用户缩放到的最大比例
     user-scalable：用户是否可以手动缩 (no,yes)
     minimal-ui：可以在页面加载时最小化上下状态栏。（已弃用）
</code></pre>

<p> 2.2 http-equiv 属性主要有</p>

<pre><code> 2.2.1 expries: 指定网页过期时间,过期必须冲浏览器重新下载
 2.2.2 pragma: 值可为no-cache,不适用缓存
 2.2.3 refresh: 指定多长时间自动刷新页面
 2.2.3 set-cookie: 设定Cookie
 2.2.4 content-type: 指定网页内容类型和字符集.

     &lt;meta http-equiv="Content-Type" content="text/html charset=utf-8"&gt;
</code></pre>

<p> 2.3 scheme 指定用来翻译属性值的方案</p></li>
</ol>


<p><code>&lt;meta&gt;</code>参考链接<a href="http://segmentfault.com/a/1190000002407912">http://segmentfault.com/a/1190000002407912</a>非常详细!、<a href="http://www.hujuntao.com/web/html/html-meta-tag.html">http://www.hujuntao.com/web/html/html-meta-tag.html</a></p>

<h2>2.4 HTML5 新增拖放API</h2>

<h3>2.4.1 拖放事件</h3>

<p>不知道你有没有发现&hellip;网页的img和a(设置了href)的标签都是可以拖动的.对于其他标签,只要设定<code>draggable="true"</code>即可拖放.标签中含有相关的触发事件</p>

<pre><code>1. ondragstart: 开始拖动触发
2. ondrag: 拖动过程不断触发
3. ondrageend: 拖动结束触发
4. ondragenter: 当拖动的元素进入本元素后触发的时间
5. ondragover: 当拖动的元素在本元素范围内将不断触发
6. ondragleave: 拖动的元素离开本元素时触发
7. ondrop: 其他元素放到本元素时触发该时间

//实现拖动一个div随意放

//取消默认事件 每个浏览器不一样.
document.ondragover =function(evt){
    //取消默认事件
    evt.preventDefault();
}

document.ondrop = function(evt){
    //取消默认事件
    evt.preventDefault();
    source.style.position = "absolute";
    source.style.left = evt.pageX+"px";
    source.style.top = evt.pageY +"px";


}
</code></pre>

<h3>2.4.2 DataTransfer对象</h3>

<p>拖放事件中的参数中有一个dataTransfer属性.该属性的方法有</p>

<ol>
<li>dropEffect: 设置或返回拖放目标上允许的拖放行为,属性值有<code>none(拖动元素不能放到本元素中)</code>,<code>copy</code>,<code>link</code>,<code>move</code>之一.且行为需要是effectAllowed中允许的行为</li>
<li>effectAllowed: 设置或返回被拖动元素允许发生的拖动行为,属性有<code>none(不允许拖动本元素)</code>,<code>copy</code>,<code>link</code>,<code>move</code>,<code>copyLink</code>,<code>copyMove</code>,<code>linkMove</code>,<code>all</code>,<code>uninitalized</code></li>
<li>items: 返回DataTransferItems对象,该对象代表了拖放数据.</li>
<li><p>setDragImage(element,x,y): element代表指定的元素,x表示图标与鼠标的水平距离,y代表纵向距离.</p>

<pre><code> //eg
 var K_Icon =document.createElement("img");
 K_Icon.src ="K.gif";

 被拖动元素.ondragestart =function(evt) {
     evt.dataTransfer.setDragImage(K_Icon,0,0);
 }
</code></pre></li>
<li><p>addElement(element): 添加自定义图标.</p></li>
<li>types: 该属性返回一个DOMStringList对象,包含了dataTransfet中所有数据类型</li>
<li>getData(format): 获取DataTransfer对象中的format格式的数据.</li>
<li>setData(format,data): 设置DataTransfer对象中格式为format的data数据.</li>
<li>clearData([format]): 清楚指定format格式数据,省略则全部删除.     <br/>
一般监听ondragstart来把数据放入DataTransfer中,监听ondrop取数据.</li>
</ol>


<p>下面代码代表页面元素拖入收藏夹的部分功能实现.</p>

<pre><code>&lt;div draggable="true" ondragstart="K(event)";&gt;...
&lt;div id="Mark_Div" draggable="true" ondrop="mark(evt)" ;&gt;...

var K = function(evt) {
    evt.dataTransfer.setData("text/plain","&lt;item&gt;"+evt.target.innerHTML);
}

var mark = function(evt){
    var text =evt.dataTransfer.getData("text/plain");
    //如果以&lt;item&gt;开头
    if (text.indexOf("&lt;item&gt;") == 0 ){
        var New_Div = document.createElement("div");
        New_Div.id =new Data().getUTCMilliseconds();
        New_Div.innerHTML = text.substring(6);
        document.getElementById("Mark_Div").appendChild(New_Div);
    }
}
</code></pre>

<h1>3 HTML5表单</h1>

<p>这里列举部分form表单属性</p>

<ol>
<li><p>enctype: 指定表单内容进行编码时候的字符集.</p>

<p> 1.1 application/x-www-form-urlencoded: 默认</p>

<p> 1.2 multipart/form-data: 二进制流 一般上传文件时使用</p>

<p> 1.3 text/plain 当表单的action未<a href="&#109;&#x61;&#105;&#108;&#116;&#x6f;&#x3a;&#85;&#x52;&#x4c;">&#85;&#x52;&#x4c;</a> 发送邮件时,采用这种方式可能比较方便</p></li>
<li><p>target: 表单也可以设置target.</p></li>
</ol>


<p>表单控件设置了disabled时,不提交此参数.</p>

<p>表单控件有tabIndex属性,值为1,2,3&hellip;,按Tab按此顺序跳动.</p>

<h2>3.1 form表单的一些标签</h2>

<ol>
<li><p><code>&lt;label...&gt;</code>: 和控件关联.</p>

<p> 1.1 隐式调用: 使用for属性关联控件的ID</p>

<p> 1.2 显式调用: 用<label>&lt;框住表单控件/label></p></li>
<li><p><code>&lt;select&gt;</code>: 下拉列表/列表框</p>

<p> 2.1 multiple: 指定可多选.</p>

<p> 2.2 size: 列表框可以显示几条数据.</p>

<p> 2.3 <code>&lt;optgroup&gt;:</code> 指定选项组, 必须定义lable属性.只能包含<code>&lt;option&gt;</code></p></li>
</ol>


<h2>3.2 HTML5新增的表单控件玩法</h2>

<ol>
<li>form: 该属性指定为form表单的id,及时该控件不在form表单内,也会随form提交.</li>
<li>formaction: 一个表单若要两个提交按钮要提交到不同的地方,在提交控件中设置不同的formaction即可.</li>
<li>formxxxx属性: 和formaction类似,为提交按钮设置不同的<code>formenctype</code>,<code>formmethod</code>,<code>formtarget</code>等.</li>
<li>autofocus: 当打开一个页面时,这个控件自动获取焦点.</li>
<li>placeholder: 提示功能,在文本框内显示提示信息,开始输入时消失.</li>
<li>list: list指定<code>&lt;datalist&gt;</code>标签中的ID,<code>&lt;datalist&gt;</code>的使用方法和select完全一样,当文本控件获取焦点时,这个<code>&lt;datalist&gt;</code>定义的下拉列表显示在文本框下.</li>
<li>autocomplete: 与list结合使用,当此属性为on,list属性起作用,为off,list属性失效.然而这并没有什么卵用.</li>
</ol>


<h3>3.2.1 input标签的type的新选项值</h3>

<ol>
<li>color: 生成一个颜色选择器.</li>
<li>date: 生成日期选择器.</li>
<li>time: 生成一个时间选择器.</li>
<li>datetime: 让生成一个UTC日期、时间选择器.</li>
<li>datetime-local: 生成一个当地的日期、时间选择器.</li>
<li>week: 生成一个第几周选择器.</li>
<li>month: 生成一个月份选择器.</li>
<li>email: 生成一个校验邮件的控件,当type=&ldquo;email&#8221;时,可指定multiple属性,表示允许输入多个email.</li>
<li>tel: 输入电话的文本框,并不怎么校验.</li>
<li>url: 校验url的文本框.</li>
<li>number: 只让输入数字的文本框.</li>
<li>range: 进度条,当type=range时候,可值得属性有<code>min</code>,<code>max</code>,<code>step(指定拖动条步长)</code>.</li>
<li>search: 输入搜索关键字,其实也并没什么卵用.</li>
</ol>


<h3>3.2.2 HTML5新增表单控件</h3>

<ol>
<li><code>&lt;output&gt;</code>: 输出变量,但不会随表单提交.</li>
</ol>


<h3>3.2.3 HTML5增强文件上传</h3>

<p>当<code>type="file"</code>时,可指定一下属性</p>

<ol>
<li>accept: 指定一个/多个允许的文件上传MIME类型,多个类型用<code>,</code>分割.例如<code>accept="image/*"</code>指定智能上传图片.<a href="http://www.w3school.com.cn/media/media_mimeref.asp">更多格式参考</a></li>
<li>multiple: 允许用户提交多个文件.</li>
</ol>


<p>JS也可以访问上传文件夹的具体属性.</p>

<ol>
<li>name: 返回File对象的文件名.</li>
<li>type: 文本的类型.</li>
<li>size: 文件的大小.</li>
</ol>


<h4>3.2.3.1 新增的FileReader对象读取文件内容</h4>

<p>FileReader对象提供以下方法.</p>

<ol>
<li>readAsText(file,encoding): 以文本格式读取文件.根据ID选择到file,encoding字符编码默认utf-8.</li>
<li>readAsBinaryString(file): 二进制读取文件,通过这种方式可以用Ajax把数据上传到服务器.</li>
<li>readAsDataUrl(file): 以DataURL方式读取文件,这种方式也可以读取二进制,但是这种方式会采用base64方式把文件内容编码成DataURL格式字符串.</li>
<li>abort(): 停止读取.</li>
<li>loaded属性: 当前FileReader已读取文件的大小.</li>
<li>result属性: 当FileReader读取完文件后,result包含读取文件的内容.</li>
</ol>


<p>但read*的所有方法都是异步的,进行时会不断触发函数.</p>

<ol>
<li>onloadstart: FileReader开始读取数据触发.</li>
<li>onprogress: FileReader读取数据时不断触发.</li>
<li>onload: FileReader成功读取后触发.</li>
<li>onloadend: FileReader读取完成触发,无论成功还是失败都会触发.</li>
<li>onerror: FileReader读取失败触发.</li>
</ol>


<p>例子:浏览器读取文件进度条,注意该方法只不过是浏览器读取文件的进度,而不是上传到服务器的进度.</p>

<pre><code>&lt;input id="file_1" type="file" /&gt;
&lt;progress id="pro" value="0"&gt;&lt;/progress&gt;
...
var Read_Binary =function(){
    var reader = new FileReader();
    var pro =document.getLementById("pro");
    pro.max = document.getElementById("file_1").files[0].size;
    reader.onprogress =function (evt){
        pro.value =evt.loaded;
    }
}
</code></pre>

<h3>3.2.4 HTML5 新增客户端校验.</h3>

<p>表单控件可增加以下属性完成校验</p>

<ol>
<li>required: 指定控件必须填写.</li>
<li>pattern: 指定符合正则表达式.</li>
<li>min、max、step: 只对数值类型,日期类型或者<code>&lt;input ../&gt;</code>起作用.,指定数值必须在min~max,并符合step步长.</li>
</ol>


<p>在JS中form对象多了checkValidity()方法,当form表单所有HTML5客户端验证通过返回true.</p>

<p>除此之外,所有表单和表单控件都有validity(ValidityState对象)属性,用于判断表单内所以控件/单个表单验证的情况.返回true/false.</p>

<p>所有表单/表单控件都有setCustomValidity(&ldquo;错误提示&rdquo;)方法,当校验没通过时,自定义的错误提示文字.</p>

<p>关闭表单校验.</p>

<ol>
<li>当form表单属性包含novalidate属性,不进行校验.</li>
<li>当提交按钮设置了 formnovalidate属性,不进行校验.</li>
</ol>


<h1>4 HTML5 绘图支持</h1>

<p><code>&lt;canvas&gt;</code>提供了一个画布.JS进行绘图,绘图步骤</p>

<ol>
<li>获取<code>&lt;canvas&gt;</code>DOM对象.</li>
<li><p>调用Canvas对象的getContext()方法,返回一个CanvasRenderingContext2D对象.</p>

<pre><code> var ctx = Canvas对象.getContext('2d');
</code></pre></li>
<li><p>调用CanvasRenderingContext2D对象的方法进行绘图.</p></li>
</ol>


<p>这部分API非常多,用法这里不主要阐述,后面有时间会单独总结.总的来说,当你的网页功能有绘图的话,这会非常重要.</p>

<h1>5 HTML5 多媒体支持</h1>

<p>简单使用</p>

<pre><code>&lt;!-- 音频 --&gt;
&lt;audio src="demo.ogg" controls&gt;
    你的浏览器不支持audio
&lt;/audio&gt;

&lt;!--视频--&gt;
&lt;video src="movie.webm" controls&gt;
    你的浏览器不支持video元素
&lt;/video&gt;
</code></pre>

<p>audio推荐使用OGG Vovis格式</p>

<p>video推荐使用VP8格式.</p>

<h2>5.1 audio和video支持的属性</h2>

<ol>
<li>src: 地址.</li>
<li>autoplay: 指定了属性装载完成后是否自动播放</li>
<li>controls: 指定了属性就有控制条.</li>
<li>loop: 指定了该属性循环播放.</li>
<li><p>preload 是否预加载,指定了autoplay,此属性无作用.</p>

<p> 5.1 auto: 预加载音频 视频</p>

<p> 5.2 metadata: 只预加载音频 视频元数据.既媒体字节数,第一帧,播放列表,持续时间.</p>

<p> 5.3 none 不预加载.</p></li>
<li><p>poster: 只对video有效,指定一个图片url,开始播放前,显示这张图片.</p></li>
</ol>


<h2>5.2 audio和video可包含标签</h2>

<ol>
<li><p><code>&lt;source ../&gt;</code> 浏览器会根据自己情况选择格式.</p>

<p> 1.1 src: 地址</p>

<p> 1.2 type: 播放格式.</p></li>
</ol>


<h2>5.3 JS控制媒体播放</h2>

<p>DOM获得对象分别是<code>HTMLAudioElement</code>或<code>HTMLVideoElement</code>,支持的方法有.</p>

<ol>
<li>play(): 播放.</li>
<li>pause(): 暂停</li>
<li>load(): 重新装载.</li>
<li><p>canPlayType(type): 判断能否播放type格式的资源,type可指定MIME字符串/codecs属性,多个格式用<code>,</code>分割,返回值有</p>

<p> 4.1 probably: 该浏览器支持type格式.</p>

<p> 4.2 maybe: 可能支持- -..</p>

<p> 4.3 空字符串: 不支持.</p></li>
</ol>


<p>在这里写一个播放多个音乐的JS函数</p>

<pre><code>var musics =[
    "K.ogg",
    "404_K.ogg",
];
var index = 0;
window.onload =function(){
    var player = Audio的DOM对象.
    palyer.src=musics[index];
    //onended在资源播放完后后触发.
    player.onended = function(){
        player.src =musics[++indx % musics.length];
        player.paly();
    }

}       
</code></pre>

<p><code>HTMLAudioElement</code>或<code>HTMLVideoElement</code>包含大量属性和时间监听.这里就不一一列举了.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CSS特效方法累积]]></title>
    <link href="http://mzkmzk.github.io/blog/2015/10/23/web_effect/"/>
    <updated>2015-10-23T11:37:40+08:00</updated>
    <id>http://mzkmzk.github.io/blog/2015/10/23/web_effect</id>
    <content type="html"><![CDATA[<!--more-->


<h1>1 鼠标移上去灰色,移走变回原来色彩.</h1>

<pre><code>.product_item {
margin: 40px 0;
-webkit-filter: grayscale(100%);
-moz-filter: grayscale(100%);
-ms-filter: grayscale(100%);
-o-filter: grayscale(100%);

filter: grayscale(100%);

filter: gray;

&amp;:hover {
  -webkit-filter: grayscale(0);
  -moz-filter: grayscale(0);
  -ms-filter: grayscale(0);
  -o-filter: grayscale(0);

  filter: grayscale(0);

  filter: none;
}
}
</code></pre>

<p>应该可以用jquery动画效果实现延迟变化的.</p>

<p>参考链接<a href="http://www.w3cplus.com/css3/ten-effects-with-css3-filter">http://www.w3cplus.com/css3/ten-effects-with-css3-filter</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[修改Bootstrap 记录]]></title>
    <link href="http://mzkmzk.github.io/blog/2015/10/20/bottstrap_update/"/>
    <updated>2015-10-20T11:37:40+08:00</updated>
    <id>http://mzkmzk.github.io/blog/2015/10/20/bottstrap_update</id>
    <content type="html"><![CDATA[<h1>1. 设置最大宽度</h1>

<p>因为设计图主题显示区域为967 但是Bootstrap在1200+分辨率下 .container的宽度为1170,所以需要修改_variable.scss</p>

<pre><code>// Large screen / wide desktop
// MaiZhiKun $container-large-desktop:      (1140px + $grid-gutter-width) !default;
$container-large-desktop:      (937px + $grid-gutter-width) !default;
</code></pre>

<h1>2. 修改导航条</h1>

<p>导航栏相关样式<code>_navbar.sass</code>,相关变量<code>_variables.scss</code></p>

<ol>
<li><p>默认灰改成透明</p>

<pre><code> !-- _variables.scss --&gt;
 $navbar-default-bg:                transparent;
</code></pre></li>
<li><p>消除导航栏圆角</p>

<pre><code> &lt;!-- _variables.scss --&gt;
 $border-radius-base:        0 ;
 $border-radius-large:       0 ;
 $border-radius-small:       0 ;
</code></pre></li>
<li><p>改变导航栏中 居中和悬浮的效果</p>

<pre><code> position: absolute !important;
 top: 0; left: 0; bottom: 0; right: 0;
</code></pre>

<p> 参考链接:<a href="http://blog.csdn.net/freshlover/article/details/11579669">http://blog.csdn.net/freshlover/article/details/11579669</a>
 <a href="http://www.smashingmagazine.com/2013/08/absolute-horizontal-vertical-centering-css/">http://www.smashingmagazine.com/2013/08/absolute-horizontal-vertical-centering-css/</a></p></li>
<li><p>导航栏增加上下间距</p>

<pre><code> &lt;!-- _variables --&gt;
 $navbar-height:                    50px !default;   
</code></pre></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[疯狂Html+CSS+JS 中CSS总结]]></title>
    <link href="http://mzkmzk.github.io/blog/2015/10/18/amazeing-css.markdwon/"/>
    <updated>2015-10-18T11:37:40+08:00</updated>
    <id>http://mzkmzk.github.io/blog/2015/10/18/amazeing-css.markdwon</id>
    <content type="html"><![CDATA[<!--more-->


<h1>0总结</h1>

<ol>
<li>第一章详细讲了各种选择器.</li>
<li>第二章讲述了字体和文本的相关属性.</li>
<li>第三章降序了背景边框的属性.</li>
<li>第四章简单讲述了大小、定位等属性.</li>
<li>第五章盒模型,重要的模型讲述得还可以.</li>
<li>第六章表格和列表还有几本的响应式属性.</li>
<li>第七章为变形和动画,通俗易懂的列举了属性</li>
<li>总体来说,这个CSS部分较为枯燥,很多属性需要知道和了解,特别是动画和变形,别太依赖JS.CSS部分具备了入门到初级前端应该知道的知识.</li>
</ol>


<hr />

<h1>1 级联样式与CSS选择器</h1>

<h1>1.1 CSS基本使用</h1>

<h3>1.1.1 引入CSS</h3>

<pre><code>/* 不建议@import 性能问题 */
&lt;link href="CSS文件路径" type="text/css" rel="stylesheet"&gt;
</code></pre>

<h2>1.2 选择器</h2>

<h3>1.2.1 元素选择器</h3>

<pre><code>/* 仅对P标签有作用 */
p{...}
</code></pre>

<h3>1.2.2 属性选择器</h3>

<pre><code>/* 仅对具有attr属性的E元素起作用 */
E[attr]{...}

/* 仅对attr=value的E元素起作用 */
E[attr=value]{...}

/* attr的值以空格为分隔符分开,其中一个值等于value即可的E元素 */
E[attr~=value]{...}

/* attr的值以连字符'_'为分隔符分开,其中一个值等于value即可的E元素 */
E[attr |=value]{...}

/* attr属性包含value值的E元素 */
E[attr*="value"]{...}

/* attr属性以value为开头的E元素 */
E[attr^="value"]{...}

/* attr属性以value为结尾的E元素 */
E[attr$="value"]{...}
</code></pre>

<h3>1.2.3 ID选择器</h3>

<pre><code>/* id为xx的元素起作用 */
#xx{...}

/* id为xx的E元素起作用 */
E#xx{...}
</code></pre>

<h3>1.2.4 class选择器</h3>

<pre><code>/* E为可选是否填写指定元素,my_class为指定lcass */
[E].my_class{...}       

/* class同时包含class1.class2 */
.class1.class2{...}
</code></pre>

<h3>1.2.5 包含选择器</h3>

<pre><code>/* div内所有class为a的元素起作用,无论元素是否为子元素 */
div .a{...} 

/*注意 包含关系有空格,同时满足关系无空格 */
.class1 .class2
</code></pre>

<h3>1.2.6 子选择器</h3>

<pre><code>/* 仅对div的子元素且class为a的元素起作用 */
div&gt;.a{...} 
</code></pre>

<h3>1.2.7 兄弟选择器</h3>

<pre><code>/* id为android的标签 之后出现的且class为long的同级元素 */
#android ~ .long{...}   
</code></pre>

<h3>1.2.8 选择器组合</h3>

<pre><code>/*逗号分隔或关系,仅符合一种选择器即起作用 */
#a,.b,div&gt;.a{...}   
</code></pre>

<h3>1.2.9 伪元素选择器</h3>

<ol>
<li>:first-letter</li>
<li>:first-line</li>
<li>:before</li>
<li>:after</li>
</ol>


<p><code>:first-letter</code>和<code>:first-line</code>可实现首字大写与首行大写之类的问题</p>

<p>注意,这两个伪属性只对块元素<code>div,p,section</code>等元素起作用,对内嵌<code>span</code>等必须设定heihht与width、或postition:absolute、或display:block.</p>

<pre><code>span{
    disply:block;
}

//首字变蓝
.span:first-letter{
    color:#00f;
}
</code></pre>

<p><code>:before</code>与<code>:after</code>用于在指定元素前/后插入内容,参考下面的内容相关属性.</p>

<h3>1.2.10 内容相关属性</h3>

<ol>
<li>include-source: 属性值为url(url)</li>
<li>content: 作用向指定元素之前或元素之后插入指定内容,该属性的值可以是字符串、url(url)、attr(alt)、counter(name)、counter(name,list-style-type)、open-quote和close-quote等格式.</li>
<li>quotes: 该属性的值可以是两个以空格分隔的字符串,前面代表open-quotes,后面带便quote.</li>
<li>counter-increment:该属性用于定义一个计数器,值为该计数器的名称.</li>
<li><p>counter-rest: 重置计数器.</p>

<pre><code> eg:
 &lt;!-- 子div前添加文字和设置样式 --&gt;
 div&gt;div:before{
     content: '文字';
     colol: blue;
 }

 &lt;!-- 含有class为on的子div之后的添加图片 --&gt;
 div&gt;div.no:after{
     content:url("K.gif");
 }

 &lt;!-- 配合quetos 对的...其实这属性貌似并没神马卵用.. --&gt;
 &lt;!-- 是的,你没猜错..其实close-quote写在before里也是可以的.. --&gt;
 div&gt;div{
     quotes: "&lt;&lt;" "&gt;&gt;";
 }

 div&gt;div:before{
     content: open-quote;
 }

 div&gt;divafter{
     content:close-quote;
 }

 &lt;!-- counter-increment添加编号1. 2. 3. --&gt;
 div&gt;div{
     counter-increment: fucking_K;
 }

 div&gt;div:before{
     content: counter{fucking_K} '.';
     font-size: 20pt;
 }

 &lt;!-- 拓展样式 更多参数&lt;https://developer.mozilla.org/zh-CN/docs/Web/CSS/list-style-type&gt; --&gt;
 div&gt;after{
     content: counter{fucking_K,lower-roman} '.';
     font-size: 20pt;
 }

 &lt;!-- 多级编号 --&gt;
 div&gt;h2{
     counter-increment: fucking_K;
 }

 div&gt;div{
     counter-increment: funcking_K2;
 }

 div&gt;h2:before{
     counter-increment: funcking_K;
     counter-reset: fucking_K2;
 }

 div&gt;div:before{
     content: counter: funcking_K2;
 }
</code></pre></li>
</ol>


<h3>1.2.11 伪类选择器</h3>

<p>Selecttor可省略.不作为匹配条件</p>

<ol>
<li><p>结构性伪类选择器</p>

<p> 1.1 Selector:rooot: HTML元素中,永远指向<code>&lt;html.../&gt;</code>元素.</p>

<p> 1.2 Selector:first-child: 匹配其父元素的第一个节点.</p>

<p> 1.3 Selector:last-child: 匹配选择器,而且是其父元素的最后一个节点.</p>

<p> 1.4 Selector:nth-child(n): 匹配选择器,而且是其父元素的第n个节点.</p>

<p> 1.5 Selector:nth-last-child(n): 匹配选择器,而且是其父元素倒数第n个节点.</p>

<p> 1.6 Selector:only-child: 匹配选择器,而且是其父元素唯一的节点.</p>

<p> 1.7 Selector:first-of-type: 匹配选择器,而且是其同类型的兄弟元素中的第一个元素.</p>

<p> 1.8 Selector:last-of-type: 匹配选择器,而且是其同类型的兄弟元素中的最后一个元素.</p>

<p> 1.9 Selecttor:nth-of-type(n): 匹配选择器,而且是其同类型的兄弟元素中的第n个元素.</p>

<p> 1.10 Selector:nth-last-of-type(n): 匹配选择器,而且是其同类型的兄弟元素中的倒数第n个元素.</p>

<p> 1.11 Selector:only-of-type: 匹配选择器,而且是其同类型的兄弟元素的唯一一个元素.</p>

<p> 1.12 Selector:only:empty: 匹配选择器,而且其内部没有任何子元素(包括文本)的元素.</p>

<p> 拿first-child和first-of-type举例</p>

<pre><code> &lt;ul&gt;
 &lt;img .../&gt;
     &lt;li&gt;...&lt;/li&gt;
 &lt;/ul&gt;

 //匹配不到任何元素,li必须是父元素的第一个元素.
 li:first-child{...}

 //匹配到li,是在父元素中匹配到的类型中的第一个即可.
 li:first-of-type{...}   
</code></pre>

<p> <code>-child匹配是会把其他不同类型的兄弟节点算进去,而-of-type只计算同类型的兄弟元素</code></p>

<p> 其中nth-child(n)、nth-last-child(n)、nth-of-type(n)、nth-last-of-type(n)支持参数</p>

<ol>
<li>odd:匹配奇数的元素</li>
<li>even:匹配偶数的元素</li>
<li>xn+y: 匹配第(x乘以n)加y的元素</li>
</ol>
</li>
<li><p>UI元素状态伪类选择器</p>

<p> 2.1 Selector:link: 匹配未访问的元素</p>

<p> 2.2 Selector:visited: 匹配访问过的元素</p>

<p> 2.3 Selector:active: 匹配处于用户被激活(鼠标点击与释放的过程中)的元素</p>

<p> 2.4 Selector:hover: 匹配鼠标悬停状态的元素</p>

<p> 2.5 Selector:focus: 匹配已得到焦点的元素</p>

<p> 2.6 Selector:enabled: 匹配当前处于可用状态的元素</p>

<p> 2.7 Selector:disabled: 匹配当前不可用状态的元素</p>

<p> 2.8 Selector:checked: 匹配当前选中状态的元素</p>

<p> 2.9 Selector:ready-only: 匹配当前只读状态的元素</p>

<p> 2.10 Selector:read-write: 匹配当前处于读写状态的元素</p>

<p> 2.11 Selector::selection: 匹配当前被选中的内容.</p></li>
<li><p>特殊的伪类选择</p>

<p> 3.1 Selector1:not(Selector2): 匹配符合Selector1选择器,但不符合Selector2选择器的元素</p>

<p> 3.2 Selector:target: 匹配符合Selector选择器且必须是命名描点的且正在被访问的目标选择器.</p>

<pre><code> :target{
     background-color: #fff;
 }

 &lt;a href="#K" /&gt;

 //当正在浏览此div,:target生效
 &lt;div id="K"&gt;
     ...
 &lt;/div&gt;
</code></pre></li>
</ol>


<h3>1.3 浏览器专属属性</h3>

<ol>
<li>-ms- IE内核</li>
<li>-moz- Gecko内核(Firefox)</li>
<li>-o- Opera浏览器</li>
<li>-webkit- Webkit内核(Chrome、Safari)</li>
</ol>


<h3>1.4 JS修改CSS</h3>

<pre><code>//修改属性
//注意属性名中采用驼峰命名,例如改变background-color,属性名要写backgroundColor
document.getElementById("id").style.属性名=属性值;

//修改class
document.getElementById("id").className=class名称;
</code></pre>

<hr />

<h1>2 字体与文本相关属性</h1>

<h2>2.1 字体相关属性</h2>

<ol>
<li>font: 可添加font-style,font-variant,font-weight,font-size,line-height,font-family等属性.</li>
<li>color: 字体颜色,可颜色名,十六进制颜色值,RGB,HSL</li>
<li>font-family: 设置字体,可用<code>,</code>分割按顺序使用字体</li>
<li>font-size: 字体大小</li>
<li>font-size-adjust: 对字体进行微调.</li>
<li>font-streth: 改变字体横向拉伸,narrower既横向压缩,wider横向拉伸.</li>
<li>font-style: 文字风格,常用属性有italic斜体,oblique倾斜体.</li>
<li>font-weight: 是否加粗,属性可数值,也可lighter、normal、bold、bolder,越来越粗.</li>
<li>text-decoration: 文字修饰线,常用属性有:none、blink闪烁、underline、line-through中划线、overline上划线.</li>
<li>font-variant: 设置文字大写字母格式,属性有normal、small-caps(小型大写字母).</li>
<li>text-shadow: 文字阴影效果,后面会详细提.</li>
<li>text-transform: 字母大小写none,capitalize首字母大写、unpercase全部大写、lowercase全部小写;.</li>
<li>line-height: 行高,负值时候可用来实现阴影效果.</li>
<li>letter-spacing: 字符之后的间隔.最后一个字不受影响</li>
<li>word-soacing: 单词之间的间隔.</li>
</ol>


<h3>2.1.1 字体添加阴影</h3>

<p>text-shadow,多组阴影用,分割</p>

<ol>
<li>color: 指定阴影颜色.</li>
<li>xoffset: 指定阴影在横向上的偏移量.(可负值)</li>
<li>yoffset: 指定阴影在纵向上的偏移量.(可负值)</li>
<li><p>redius: 指定阴影的模糊半径,半径越大越模糊    .</p>

<pre><code> &lt;!-- 向右下角和左上角加阴影加阴影--&gt;
 &lt;span style="text-shadow:5px 5px 2px gray,-5px 5px 2px gray"&gt;帅哥麦&lt;/span&gt;
</code></pre></li>
</ol>


<h3>2.1.2 微调字体大小</h3>

<p>font-size-adjust用调节同样字号不同字体的效果.</p>

<p>font-size-adjust通过设定aspect值从而控制不同字体的大小.</p>

<p>aspect等于字体小写x的高度除以该字体的大小.</p>

<pre><code>    #div {
        font-size: 16pt;
        font-family: "狂草";
        font-size-adjust:0.52;
    }   

    #div2 {
        font-size: 16pt;
        font-family: "楷书";
        font-size-adjust: 1.22;
    }
</code></pre>

<h2>2.2 CSS3支持的颜色表示方法</h2>

<ol>
<li>颜色名:white,red,greenyellow</li>
<li>十六进制</li>
<li>rgb(r,g,b)</li>
<li>rgba(r,g,b,a): a在0~1之间,0表示完全透明</li>
<li>hsl(hue,saturation,lightness):色调,饱和度,亮度控制.</li>
<li>hsla(h,s,l,a).</li>
</ol>


<h2>2.3 文本相关属性</h2>

<p>此类属性用于控制整段或整个div的</p>

<ol>
<li>text-indent: 文本的缩进</li>
<li><p>text-overflow:</p>

<p> 2.1 clip: 要指定overflow:hidden,隐藏溢出的文字</p>

<p> 2.2 ellipsi: 要指定了overflow:hidden,溢出时候用&hellip;标记</p></li>
<li><p>vertical-align:指定内容垂直方式</p>

<p> 3.1 auto: 自动对齐</p>

<p> 3.2 baseline: 默认值,将支持valign属性的元素的文本内容与基线对齐</p>

<p> 3.3 sub: 文本下标对齐</p>

<p> 3.4 super: 文本上标对齐</p>

<p> 3.5 top: 默认值,将支持valign属性的元素的文本内容与元素的顶端对齐</p>

<p> 3.6 middle: 默认值,将支持valign属性的元素的文本内容对齐到元素的中间.</p>

<p> 3.7 bottom: 默认值,将支持valign属性的元素的文本内容与元素的底端对齐.</p></li>
<li><p>text-align: left,right,center,justify(两端对齐)</p></li>
<li><p>direction: 用于设置文本流入的方式,ltr(左到右),rtl(右到左),不会影响数字和拉丁文字母(除拉丁文标点符号).</p></li>
<li><p>word-break: 用于设置目标组件中文本的换行方式</p>

<p> 6.1 normal: 按浏览器默认,西方文字:只会在半角空格、连字符地方换行.中文,任意文字后换行.</p>

<p> 6.2 keep-all: 只能在半角空格或连字符换行</p>

<p> 6.3 break-all: 允许在连续单词中间换行</p></li>
<li><p>white-space:处理目标组件中文本对空格的处理</p>

<p> 7.1 normal: 自动换行</p>

<p> 7.2 nowrap: 强制文本一行显示,除非遇到<code>&lt;br /&gt;</code></p></li>
<li><p>word-wrap: 用于设定目标组中文本内容的换行方式</p>

<p> 8.2 normal: 浏览器默认</p>

<p> 8.3 break-word: 允许单词中间换行.</p></li>
</ol>


<p>word-break兼容性不好,单词中换行最好使用<code>word-wrap:breakword;</code></p>

<p>word-break和word-wrap区别:</p>

<ol>
<li><p>word-break: break-all:会让每一行文本最后一个单词换行.(不浪费一点空间)</p></li>
<li><p>word-wrap: break-word:会让太长单词之前自动换行.</p></li>
<li><p>情况很多,不好理解.具体参考<a href="http://www.cnblogs.com/2050/archive/2012/08/10/2632256.html">http://www.cnblogs.com/2050/archive/2012/08/10/2632256.html</a></p></li>
</ol>


<h2>2.4 服务器字体</h2>

<ol>
<li>下载.ttf/.otf字体</li>
<li><p>定义服务器字体</p>

<pre><code> &lt;!-- src ...;后可跟字体样式属性 --&gt;
 @font-fave {
     font-family: 404_K;
     src: url(url) format("字体格式");
     font-weight: blod;
 }
</code></pre></li>
</ol>


<h3>2.4.1 优先使用客户端字体</h3>

<pre><code>    @font-fave {
        font-family: 404_K;
        src: location("微软雅黑"),url(url) format("字体格式");
        font-weight: blod;
    }
</code></pre>

<hr />

<h1>3 背景、边框和补丁相关属性</h1>

<h2>3.1 背景相关属性</h2>

<ol>
<li>background: 可控制背景颜色、背景图片、背景重复方式.</li>
<li><p>background-attachment: 背景图片是否随对象内容滚动还是固定.</p>

<p> 2.1: scorll:背景随内容滚动</p>

<p> 2.2 fixed:背景图片固定.</p></li>
<li><p>background-color: 背景色</p></li>
<li>background-image: 背景图片,背景图片会覆盖背景色(假如同时设置了).</li>
<li>background-position: 可百分百可数值,只设横百分比,纵百分比为50%.</li>
<li><p>background-repeat:是否平铺</p>

<p> 6.1 repeat:平铺</p>

<p> 6.2 repeat-x:横向平铺</p>

<p> 6.3 repeat-y:纵向平铺</p>

<p> 6.4 no-repeat:不平铺</p></li>
</ol>


<hr />

<p>以下为CSS3新增</p>

<ol>
<li><p>background-clip: 指定背景覆盖范围.</p>

<p> 7.1 border-box: border-box(覆盖border,padding,content)</p>

<p> 7.2 padding-box: 覆盖padding,content(默认)</p>

<p> 7.2 content-box,只覆盖content.</p></li>
<li><p>background-origin: 设置背景覆盖的起点,有点和background-position类似.或指定从哪个区域的开始放置背景图片(content,padding,border).Chrome和Safari使用要开-webkit开头.</p></li>
<li><p>background-size: 设置图片大小.</p>

<p> 9.1 数值: 12px,13px 占宽12px,高13px;</p>

<p> 9.2 百分比: eg 80% 10%,宽占百分之80,高占百分之10%</p>

<p> 9.3 auto:只有一个值能为auto,根据另外一个值自动缩放(这个对响应式非常有用,保证图片不走形 100% auto,完全显示图片).</p></li>
</ol>


<p>CSS3提供了多背景控制,属性还是上面的,多个背景属性用,隔开.</p>

<h2>3.2 边框相关属性</h2>

<ol>
<li>border: 设置边框样式,粗细,线型,颜色.</li>
<li>border-color: 边框颜色..任何颜色值</li>
<li><p>border-style: 边框样式</p>

<p> 3.1 none:无边框</p>

<p> 3.2 hidden: 隐藏边框,于none类似,当在表中可解决边框冲突</p>

<p> 3.3 dotted: 电线边框</p>

<p> 3.4 dashed: 虚线边框</p>

<p> 3.5 solid: 实现边框</p>

<p> 3.6 double: 双线边框</p>

<p> 3.7 grove: 3D凹槽边框</p>

<p> 3.8 ridge: 3D凸槽边框</p>

<p> 3.9 inset: 3D凹入边框</p>

<p> 3.10 outset: 3D凸出边框(个人感觉3.7,3.8和3.9,3.10类似,不过立体感弱一点)</p></li>
<li><p>border-width: 边框线框.任何有效长度值.若只设width,是没法占位置的.</p></li>
</ol>


<hr />

<p>以下top bottom right left皆有.</p>

<ol>
<li>border-top: 设置上线的复合属性,可设置边框样式,粗细,线型,颜色.</li>
<li>border-top-color: 上边框颜色.</li>
<li>border-top-style: 边框样式</li>
<li>border-top-width: 上边线框.</li>
<li>border-top-colors: 渐变属性,CSS3新增,假设border-top-width为Npx,则可以设置N种颜色,从外框往里渐变,若设置的颜色个数小于width,最后一个颜色会作为之后的颜色.</li>
</ol>


<hr />

<p>圆角边框,CSS3新增</p>

<ol>
<li>border-radius: 圆角边框,数值代表圆角半径,半径越大,越圆,</li>
<li>还有border-top-left-radius、border-top-right-radius、border-bottom-left-radius、border-bottom-right-radius属性.</li>
</ol>


<hr />

<p>图片边框</p>

<ol>
<li>border-image: 语法:<code>&lt;border-image-source&gt;  &lt;border-image-slice&gt;[/boder-image-width]?  &lt;border-image-repeat&gt;</code></li>
<li>border-image-source: none/url(&ldquo;图片路径&rdquo;)</li>
<li>border-image-slice: 可输1~4个百分比或数值用于切割图片,按上下左右切割,得出9张小图片,默认情况中间会丢弃.但例如 10 20&amp;&amp;fill中间就会保留放在内容中间.</li>
<li>border-image-width: 为上面切割的图片设置宽度.可设置1~4个长度,百分比,或auto,指定image-slice的宽度.</li>
<li><p>border-iamge-repeat: 指定图片覆盖方式.可设0~2个值,分别代表横竖.</p>

<p> 5.1 stretch: 拉伸覆盖</p>

<p> 5.2 repeat: 平铺覆盖</p>

<p> 5.3 round: 取整平铺,和repeat类似,</p>

<pre><code> 当最后一张图片不能显示超过一半,则不显示最后一张图片,通过拉伸前面的图片实现填充.

 当最后一张图片可以显示超过一半,则显示最后一张图片,压缩前面的图片.
</code></pre></li>
</ol>


<p>border存在则border-image相关属性不起作用.</p>

<h1>3 大小、定位、轮毂相关属性</h1>

<h2>3.1 大小相关属性</h2>

<ol>
<li>height: 设定高度</li>
<li>max-height: 设定最大高度.当此属性小于min-height,则自动转化为min-height,下面属性同理</li>
<li>min-height: 设定最小高度.</li>
<li>width: 设定宽度</li>
<li>max-width: 最大宽度</li>
<li>min-widht: 最小宽度</li>
</ol>


<p>CSS3新增属性</p>

<ol>
<li><p>box-sizing: 用于设定width和height控制content padding border等哪些区域.</p>

<p> 1.1 content-box: 只控制content</p>

<p> 1.2 padding-box: 控制content+padding</p>

<p> 1.3 border-box: 控制contetn+padding+border</p></li>
<li><p>resize: 设置用户能否拖动组件来改变组件的大小</p>

<p> 2.1 none: 不能改变大小</p>

<p> 2.2 both: 能改变大小,但只能按比例缩放</p>

<p> 2.3 horizontal: 不允许改变高度,能改变宽度</p>

<p> 2.4 vertical: 不允许改变宽度,能改变高度</p></li>
</ol>


<h2>3.2 定位相关属性</h2>

<p>定位作用为在于布局,漂浮~.除了position以外的其他属性不对static起作用.</p>

<ol>
<li><p>position 定位方式</p>

<p> 1.1 absolute: 组件会漂浮在页面上,不考虑周围内容</p>

<p> 1.2 relative: 参考前一个组件的位置来定位</p>

<p> 1.3 static: 默认值,没有定位,元素出现在正常的页面流中.</p>

<p> 1.4 fixed: 绝对定位,以浏览器为定位参考</p></li>
<li><p>z-index: 数值觉得漂浮重叠优先级.数值越高优先级越高.</p></li>
<li>top: 设定最近一个具有定位设置的父元素向顶部偏移.</li>
<li>right: 设定最近一个具有定位设置的父元素向右侧偏移.</li>
<li>bottom: 设定最近一个具有定位设置的父元素向底部偏移.</li>
<li>left: 设定最近一个具有定位设置的父元素向顶部偏移.</li>
</ol>


<p>漂浮居中定位设置很常用的一招.</p>

<pre><code>margin: auto;  
position: absolute;  
top: 0; left: 0; bottom: 0; right: 0; 
</code></pre>

<p>原理及其它居中方式<a href="http://blog.csdn.net/freshlover/article/details/11579669">http://blog.csdn.net/freshlover/article/details/11579669</a>.</p>

<h3>3.3 轮廓相关属性</h3>

<p>轮廓不占页面实际物理布局面积,可实现&#8221;光晕效果&#8221;.</p>

<ol>
<li>outline: 可设置轮廓颜色 线宽 线型.</li>
<li>outline-color: 轮廓颜色.</li>
<li>outline-style: 和之前的border-style一致.</li>
<li>outline-width: 轮廓宽度.</li>
<li>outline-offset: 设置轮廓和边框的距离</li>
</ol>


<h1>4 盒模型与布局相关属性</h1>

<h2>4.1 布局相关属性</h2>

<ol>
<li>float: 可left/right.当设置了该属性强制display为block,它会紧靠组件的左/右,直到遇到边框/padding/margin或另外一块组件(displ为block)为止.)</li>
<li><p>clear: 设置该组件能否出现浮动组件.</p>

<p> 2.1 none: 默认,你随便飘~</p>

<p> 2.2 left: 不允许出现左飘~</p>

<p> 2.3 right: 不允许出现右飘~</p>

<p> 2.4 both: 你丫的别给我飘~.</p></li>
<li><p>clip: 对组件裁剪设置,(只有在position为absolute且overflow:hidden,效果才会较好.)</p>

<p> 3.1 rect(Num_A,Num_B,Num_C,Num_D),定义一个矩形,只有在矩形内才显示出来.这4个数有点奇葩,和别的不一样,定义的矩形为,横向显示(Num_D~Num_B)的内容,纵向显示(Num_A~Num_C)的内容.  当Num为auto,表示该边不做裁剪.</p></li>
<li><p>overflow: 设置等组件不能容纳内容显示时,采取的措施</p>

<p> 4.1 visble: 默认,不剪切也不加滚动条.</p>

<p> 4.2 auto: 添加滚动条显示全部内容.</p>

<p> 4.3 hidden: 裁剪不能显示的部分.</p>

<p> 4.4 scroll: 不够内容有没有超,总显示滚动条.</p></li>
<li><p>overflow-x: 仅对横向方向起作用,属性同overflow.</p></li>
<li>overflow-y: 仅对纵向起作用.属性同overflow.</li>
<li>visibility: visibl/hidden.隐藏时仍占据网页空间</li>
<li><p>display: 设置盒模型.</p>

<p> 8.1 block类型: 默认占据一行,可CSS设置宽高度,默认此属性的元素有<code>&lt;div&gt;、&lt;p&gt;、&lt;h1&gt;...&lt;h6&gt;、&lt;ol&gt;、&lt;ul&gt;、&lt;dl&gt;、&lt;table&gt;、&lt;address&gt;、&lt;blockquote&gt; 、&lt;form&gt;</code>等.</p>

<p> 8.2 inline类型: 默认允许一行放多个组件,CSS设置宽高度无作用.默认此属性的元素有<code>&lt;a&gt;、&lt;span&gt;、&lt;br&gt;、&lt;i&gt;、&lt;em&gt;、&lt;strong&gt;、&lt;label&gt;、&lt;q&gt;、&lt;var&gt;、&lt;cite&gt;、&lt;code&gt;</code>等.当两个block中间有inline他们是不可以在同一行的,</p>

<p> 8.3 none: 隐藏组件,不占网页空间.</p>

<p> 8.4 inline-block盒模型: 不占据一行,但可以设置宽高度.这个也可以实现多栏布局.默认情况下,多个inline-block盒模型会对齐底部.改变对齐顶部使用<code>vertical-align:top</code>,默认此属性的元素有<code>&lt;img&gt;、&lt;input&gt;</code>等.当两个block中间有inline-block他们是可以在同一行的,</p>

<p> 8.5 inline-table盒模型: 与inline-block类似,分别在表格设置inline-table或inline-block,但是inline-table设置width会拉伸单元格,inline-block会把内容多余的空间在右边留白,而不是给单元格.</p>

<pre><code> //关于表格的盒模型,其实作用不大,作用大概就是可以把div当做表格来显示.
 1. table: 将组件变为表格.
 2. table-caption: 将组件变为表格标题.
 3. table-cell: 将组件变为单元格.
 4. table-column: 将组件变为表格列.
 5. table-column-group: 将组件变为表格列组.
 6. table-row: 将组件变为表格行.
 7. table-row-group: 将组件变为表格列组.
 8. table-header-group: 将组件变为表格头部分.
 9. table-footer-group: 将组件变为表格尾部分.
</code></pre>

<p> 8.6 list-item盒模型: 可以将组件转为ul等列表元素.</p>

<p> 8.7 run-in盒模型: 和inline类似,但假如后面紧跟block,那么run-in会包含在后面的block中.
 8.8 box模型: CSS3新增.当disp为box时,组件可以使用以下的属性控制box</p>

<pre><code> 1. box-orient:horizontal/vertical. 

     1.1 当属性为horizontal时候,没有为子元素定义高度,则高度等于父元素的高度.

     1.2 当属性为vertical时候,没有为子元素定义宽度,则高度等于父元素的宽度.

 2. box-oridinal-group: 设置box盒模型中子元素的显示顺序.

 3. box-flex: 设置模型自动适应宽度比例,

     3.1 例如box盒模型多余150px,第一个元素的box-flue为1,第二个元素的box-flue为2,则把多余的宽度分50px给第一个元素,分100px给第二个元素.  
</code></pre></li>
</ol>


<h2>4.2 给盒子加阴影</h2>

<p>CSS3新增的,主要使用box-shadow属性.是一个复合属性,包括以下5个属性.</p>

<ol>
<li>hOffset: 控制阴影在水平方向的偏移.</li>
<li>vOffset: 控制阴影在纵向的偏移.</li>
<li>blurLength: 控制阴影的模糊程度.</li>
<li>scaleLength: 控制阴影的缩放程度.</li>
<li>color: 控制阴影颜色</li>
</ol>


<p>eg:</p>

<pre><code>&lt;!-- 右下阴影,模糊程度10px,缩小阴影区域-10px --&gt;
&lt;div style="box-shadow: 10px 8px 10px -10px red"&gt;..&lt;/div&gt;
</code></pre>

<h2>4.3 column-count分栏</h2>

<p>column-count分栏为CSS3新增,属性主要有:</p>

<ol>
<li>columns: 复合属性,可指定栏目宽度,栏目数.但内容大于容器时,Firefox和Chrome会增加每栏的宽度,Opera会保持栏目宽度,但增加栏目数.</li>
<li>column-width: 指定每个栏目的宽度.</li>
<li>column-count: 指定栏目个数.</li>
<li>column-rule: 符合属性,指定栏目之间分隔条的宽度 样式 颜色.</li>
<li>column-rule-width: 指定分隔条的宽度.</li>
<li>column-rule-style: 指定分隔条的样式,属性和border-style的样式一样.</li>
<li>column-rule-color: 指定分隔条的颜色.</li>
<li>column-gap: 设定栏目的间距.</li>
<li><p>column-fill: 设定栏目的高度</p>

<p> 9.1 auto: 根据内容多少变化高度.</p>

<p> 9.2 balance: 高度统一为最长的那栏的高度.</p></li>
</ol>


<h1>5 表格、列表及media query</h1>

<h2>5.1 表格相关属性</h2>

<ol>
<li><p>border-collapse: 控制两个单元格的边框分开还是合并.</p>

<p> 1.1 seperate: 边框分开.(双线)</p>

<p> 1.2 collapse: 边框合并.(单线)</p></li>
<li><p>border-spacing: 前提为border-collapse为seperate时,设置分割间距.</p></li>
<li>caption-side: 设置表格标题在表格的哪边,必须与<code>&lt;caption.../&gt;</code>一块使用,属性有top bottom/left/right.</li>
<li>empty-cells: 前提为border-collapse为seperate,设置单元格为空时,是否显示单元格边框,属性有show/hide.</li>
<li><p>table-layout: 设置表格宽度布局方法.</p>

<p> 5.1 auto: 默认值.</p>

<p> 5.2 fixed 固定布局.</p>

<pre><code> //fixed表格宽度计算方式.
 1. 如果设置了&lt;col../&gt;或&lt;colgroup../&gt;每列的宽度,则表格宽度等于所有列宽的总和.
 2. 如果表格内第一个单元格设置了宽度,则表格宽度所有所以列宽的总和.
 3. 直接平均分配每列的宽度,忽略单元内容的实际宽度.
</code></pre></li>
</ol>


<h2>5.2 列表相关属性</h2>

<ol>
<li>list-style: 复合属性,可以指定list-style-image list-style-position list-style-type.</li>
<li>list-style-image: 指定列表标记的图片.</li>
<li><p>list-style-position: 设定列表标记出现的位置</p>

<p> 3.1 outside: 列表项标记防盗列表元素之外.</p>

<p> 3.2 inside: 列表想标记放在列表元素之内.</p></li>
<li><p>list-style-type : 设置项标记符号,list-style-image会覆盖list-style-type属性,全部属性<a href="http://www.w3school.com.cn/cssref/pr_list-style-type.asp">参考</a>.常用的有</p>

<p> 4.1 decimal: 默认,阿拉伯数字.</p>

<p> 4.2 disc: 实心圆</p>

<p> 4.3 upper-roman: 大写罗马数字.</p>

<p> 4.4 none: 不使用符号.</p>

<p> 4.5 lower-alpha: 小写英文字母</p>

<p> 4.6 upper-alpha: 大写英文字母</p></li>
</ol>


<h2>5.3 控制光标的属性</h2>

<p>cursor属性控制光标属性</p>

<ol>
<li>auto: 默认</li>
<li>default: 默认光标(一般是箭头).</li>
<li>all-scroll: 代表十字箭头光标.</li>
<li>col-resize: 代表水平拖动线光标.</li>
<li>crosshair: 代表十字线光标.</li>
<li>more: 移动十字箭头光标.</li>
<li>help: 带问号光标.</li>
<li>no-drop: 禁止光标.</li>
<li>not-allowed: 和no-drop一样.</li>
<li>pointer: 代表手型光标.</li>
<li>progress: 代表漏沙光标.</li>
<li>wait: 和progress一样.</li>
<li>row-resize: 代表垂直拖动光标.</li>
<li>text: 文本编辑光标.</li>
<li>vertical-text: 代表垂直文本编辑光标.</li>
<li>*-resize: 该属性*可为n(上) s(下) e(右) w(左) 方向的光标.*可为1位或2位,例如nw-resize代表指向上右的光标.</li>
</ol>


<h2>5.4 media query功能</h2>

<p>语法</p>

<pre><code>@media [not|only] 设备类型 [and 设备特性]*
</code></pre>

<ol>
<li>all: 所有设备.</li>
<li>aural: 适用于语音和音频合成器.</li>
<li>braille: 适用于触觉反馈设备.</li>
<li>embossed: 使用凸点字符(盲文)印刷设备.</li>
<li>handheld: 适用于小型或手提设备.</li>
<li>print: 适用于打印机.</li>
<li>projection: 适用于投影图像,如幻灯片.</li>
<li>screen: 适用于计算机显示器.</li>
<li>tty: 适用于固定间距字符格的设备,如电传打字机和终端.</li>
<li>tv: 适用于电视类设备.</li>
</ol>


<p>设备特性中的值<a href="http://blog.csdn.net/lee_magnum/article/details/12144187">参考</a></p>

<p>最常用的设备特新为 min-width和max-width.</p>

<p>一般使用的代码</p>

<pre><code>@media screen and (min-width: ***px){...}
</code></pre>

<h1>6 变形与动画相关属性.</h1>

<h2>6.1 CSS3提供的变形支持</h2>

<ol>
<li><p>transform: 设置1个或多个变形函数,设置变形函数顺序和重要,按顺序变形,变形函数有</p>

<p> 1.1 translate[tx[,ty]]: 横向移动tx,纵向移动ty.,ty不写则不移动.</p>

<p> 1.2 translateX(tx): 横向移动tx.</p>

<p> 1.3 translateY(ty): 纵向移动ty.</p>

<p> 1.4 scanle(sx[,sy]): 横向缩放比为sx,纵向缩放比为sy,但sy不填,则缩放比为sx.</p>

<p> 1.5 scanleX(sx): scanle(sx,1).</p>

<p> 1.6 scanleY(sy): scanle(1,sy).</p>

<p> 1.7 rotate(angle): 顺时针转angle角度.</p>

<p> 1.8 skew(sx [,sy]): 沿X轴倾斜sx角度,沿Y轴倾斜sy角度.省略sy,sy为0.</p>

<p> 1.9 skewX(sx): skew(sx);</p>

<p> 1.10 skewY(sy): skew(0,sy);</p>

<p> 1.11 matrix(m11,m12,m21,m22,dx,dy): 基于矩阵变换,前4个参数组成变形矩形,dx、表示对坐标系统进行平移.</p>

<pre><code> //按照矩形变换公司最后变形坐标计算公式,其实变形函数都是通过这个函数实现的.
 (x*m11+y*m21+dx,x*m12+y*m22+dy);
</code></pre></li>
<li><p>transform-origin: xCenter yCenter ,设置变形中心点,可选值有左上角 左下角 右下角 右上角</p>

<p> 2.1 xCenter可为left/right</p>

<p> 2.2 yCenter可为top/bottom</p></li>
</ol>


<h2>6.2 CSS3提供的Transition</h2>

<p>transition属性指定下面4部分,可设置多组动画,用<code>,</code>分割.</p>

<ol>
<li>transition-property:指定组件的哪个CSS属性进行平滑渐变,可指定background-color,width,height等标准CSS属性.</li>
<li>transition-duration: 渐变时间.</li>
<li><p>transition-timing-function: 渐变速度</p>

<p> 3.1 ease: 先慢后快再慢.</p>

<p> 3.2 linear: 速度不变.</p>

<p> 3.3 ease-in: 先慢后快</p>

<p> 3.4 ease-out: 先快后慢.</p>

<p> 3.5 ease-in-out: 和ease类似.</p>

<p> 3.6 cubic-bezier(x1,y1,x2,y2): 通过贝济埃曲线控制动画.</p></li>
<li><p>transition-delay: 指定延迟时间.延迟多久后开始渐变</p></li>
</ol>


<p>eg:</p>

<pre><code>div{
    浏览器前缀-transition: background-color 4s linear 4s.
}   
</code></pre>

<h2>6.3 CSS 3提供的Animation动画</h2>

<p>Animation动画提供一下几个属性.</p>

<ol>
<li>animation 复合属性,可同时按顺序设置下面的属性.</li>
<li>animation-name: 动画名称,指向一个已有的关键帧.</li>
<li>animation-duration: 制动动画的持续时间.</li>
<li>animation-timing-function: 指定动画的变化速度.</li>
<li>animation-delay: 延迟多久开始执行动画.</li>
<li>animation-iteration-count: 指定动画循环次数.数值/infinite为无数次,</li>
</ol>


<p>关键帧定义格式:</p>

<pre><code>keyframes 关键帧名称 {
    form | to | 百分比 {
        css属性1 : 属性值1;
        ...
    }
    ...
}
</code></pre>

<p>eg 实现鼠标hover时放大div:</p>

<pre><code>@-webkit-keyframes '404_K' {
    0% {
        -webkit-transform: scale(1);
    }

    50% {
        -webkit-transform: scale(2);
    }

    100% {
        -webkit-transform: scale(1);
    }
}
...
div&gt;a:hover {
    -webkit-animation-name: '404_K' ;
    -webkit-animation-duration: 3s;
    -webkit-animation-iteration-count: infinite;
} 
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Sass入门]]></title>
    <link href="http://mzkmzk.github.io/blog/2015/10/16/sass_start/"/>
    <updated>2015-10-16T11:37:40+08:00</updated>
    <id>http://mzkmzk.github.io/blog/2015/10/16/sass_start</id>
    <content type="html"><![CDATA[<!--more-->


<h1>0 前面工作</h1>

<ol>
<li>本文主要使用bootstrap3的sass,下载链接<a href="http://v3.bootcss.com/getting-started/">http://v3.bootcss.com/getting-started/</a></li>
<li>安装Ruby,sass基于Ruby开发的</li>
<li><p>gem install sass 安装sass</p>

<p> 3.1 安装失败,显示</p>

<pre><code> ERROR:  Could not find a valid gem 'sass' (&gt;= 0), here is why:
   Unable to download data from http://ruby.taobao.org/ - bad response Not Found 404 (http://ruby.taobao.org/latest_specs.4.8.gz)
</code></pre>

<p> 可能由于我之前安装octopress的时候换了Ruby使用淘宝镜像,现在淘宝镜像可能没有sass的了.</p>

<p> 网上查了下解决方案,大多数还是说去淘宝的rubygems.org</p>

<p> 参考<a href="https://github.com/nimojs/blog/issues/14">https://github.com/nimojs/blog/issues/14</a></p>

<pre><code> //执行这句后的提示我是害怕的,什么鬼...和教程显示得不一样啊,但是勇敢的我还是去访问了下https://rubygems.org/,发现有这个网址的啊...于是尝试下去
 K:bootstrap-sass-3.3.5 maizhikun$ gem sources --remove https://rubygems.org/
 source https://rubygems.org/ not present in cache

 //和教程一致了...
 K:bootstrap-sass-3.3.5 maizhikun$ gem sources -a https://ruby.taobao.org/
 https://ruby.taobao.org/ added to sources

 //执行到这里大家可能明白了,可能ruby.taobao之前我使用的时候是http的,现在改为https,所以会导致一开始的错误.
 K:bootstrap-sass-3.3.5 maizhikun$ gem source -l
 *** CURRENT SOURCES ***

 http://ruby.taobao.org/
 https://ruby.taobao.org/

 //额,,常见的权限问题..
 K:bootstrap-sass-3.3.5 maizhikun$  gem install sass
 Fetching: sass-3.4.19.gem (100%)
 ERROR:  While executing gem ... (Gem::FilePermissionError)
     You don't have write permissions for the /Library/Ruby/Gems/2.0.0 directory.

 //找到提示的目录更改权限 原本权限是755,改为775还是不行,于是777~...然后就可以下载了..但是报了另外一个权限问题
 K:bootstrap-sass-3.3.5 maizhikun$  gem install sass
 Fetching: sass-3.4.19.gem (100%)
 ERROR:  While executing gem ... (Gem::FilePermissionError)
     You don't have write permissions for the /usr/bin directory.

 //于是机智的我..发现这样chmod不是办法...sudo试试...
 K:bootstrap-sass-3.3.5 maizhikun$ sudo  gem install sass
 Successfully installed sass-3.4.19
 Parsing documentation for sass-3.4.19
 Installing ri documentation for sass-3.4.19
 Done installing documentation for sass after 5 seconds
 WARNING:  Unable to pull data from 'http://ruby.taobao.org/': bad response Not Found 404 (http://ruby.taobao.org/latest_specs.4.8.gz)
 1 gem installed
 //管她呢.....WARNING而已..不理...不理....就好像上班迟到收警告一样~..
</code></pre>

<p> 让我们见证一下奇迹吧.</p>

<pre><code> K:bootstrap-sass-3.3.5 maizhikun$ sass -v
 Sass 3.4.19 (Selective Steve)
</code></pre>

<p> OK了,准备爽一发吧.</p></li>
</ol>


<h1>1 简单实践</h1>

<ol>
<li><p><code>sass _bootstrap.scss test2.css</code></p>

<p> 会生成test2.css和test2.css.map</p></li>
<li><p><code>sass _bootstrap.scss</code></p>

<p> 会在控制台显示转化的代码</p></li>
<li><p>SASS提供的四种编译风格选项<a href="http://sass-lang.com/documentation/file.SASS_REFERENCE.html#output_style">官网参考</a></p>

<p> 3.1 nested: 默认值,嵌套缩进css代码.</p>

<p> 3.2 expanded: 没有缩进、拓展的css代码.</p>

<p> 3.3 compact: 简洁格式的css代码.</p>

<p> 3.4 compressed: 压缩后的css代码.</p>

<p> 例子:<code>sass --style compressed test.sass test.css</code></p></li>
<li><p>sass监听某个文件/目录,一旦源文件变动,就自动编译</p>

<pre><code> //watch afile 
 sass --watch input.scss:output.css

 // watch a directory 

 sass --watch app/sass:public/stylesheets
</code></pre>

<p> SASS的官方网站，提供了一个在<a href="http://sassmeister.com/">线转换器</a>。你可以在那里，试运行下面的各种例子.</p></li>
</ol>


<h1>2 基本语法</h1>

<ol>
<li><p>变量</p>

<pre><code> $blue: #1875e7;

 div{
     color : $blue;
 }
</code></pre>

<p> 如果变量需要嵌套在字符串上必须加上#{}</p>

<pre><code> $side : left;

 .rounded{
     border-#{$side}-radius: 5px;
 }
</code></pre></li>
<li><p>计算功能</p>

<pre><code> body {
     magin: (14px/2);
     top: 50px +100px;
     right: $var * 10%;
 } 
</code></pre></li>
<li><p>嵌套</p>

<p> 标签嵌套</p>

<pre><code> div {
     hi{
         color:red;
     }
 }
</code></pre>

<p> 属性嵌套</p>

<pre><code> //border-color属性
 p{
     border: {
         color:red ;
     }
 }
 //注意border后的冒号
</code></pre>

<p> 嵌套中引用父级级元素</p>

<pre><code> a{
     &amp;:hover {
         color : #ffb3ff;
     }
 }
</code></pre></li>
<li><p>注释</p>

<pre><code> //: 保留在sass不会输出到css

 /* 注释*/: 会保留在生成的css文件中,但不会保留在压缩模式

 /*!
     重要信息,任何时候都会保留,一般用作声明版权
 */
</code></pre></li>
<li><p>继承</p>

<pre><code> .class1 {}

 .class2 {
     @extend .class1;
     ...
 }
</code></pre></li>
<li><p>Mixin 可重用代码块</p>

<pre><code> //定义代码块
 @mixin left {
     float: left ;
 }

 //调用代码块
 div{
     @include left;
 }

 mixin强大在于可以指定参数和缺省值

 @mixin left($value: 10px){
     margin-right: $value;
 }

 //使用
 div{
     @include left(20px);
 }

 //下面实例用来生成浏览器前缀
 @mixin rounded($vert, $horz, $radius: 10px) {
     border-#{$vert}-#{$horz}-radius: $radius;
     -moz-border-radius-#{$vert}#{$horz}: $radius;
     -webkit-border-#{$vert}-#{$horz}-radius: $radius;
 }

 //调用
 #navbar li { @include rounded(top, left); }
 #footer { @include rounded(top, left, 5px); }
</code></pre></li>
<li><p>颜色函数</p>

<pre><code> lighten(#cc3, 10%) // #d6d65c
 darken(#cc3, 10%) // #a3a329
 grayscale(#cc3) // #808080
 complement(#cc3) // #33c        
</code></pre></li>
<li><p>插入外部文件</p>

<pre><code> 　@import "path/filename.scss";
 　@import "foo.css";
 　
</code></pre></li>
<li><p>高级用法</p>

<p> 9.1 if , if else</p>

<pre><code>     　p {
     　   @if 1 + 1 == 2 { border: 1px solid; }
     　   @if 5 &lt; 3 { border: 2px dotted; }
     　}
     　
     　@if lightness($color) &gt; 30% {
     　     background-color: #000;
     　} @else {
     　     background-color: #fff;
     　}
</code></pre>

<p> 9,2 for,while,each</p>

<pre><code>     @for $i from 1 to 10 {
         .border-#{$i} {
             border: #{$i}px solid blue;
         }
     }

     $i: 6;
     @while $i &gt; 0 {
         .item-#{$i} { width: 2em * $i; }
         $i: $i - 2;
     }

     @each $member in a, b, c, d {
         .#{$member} {
             background-image: url("/image/#{$member}.jpg");
         }
     }
</code></pre>

<p> 9,3 自定义函数</p>

<pre><code> 　@function double($n) {
 　 @return $n * 2;
 　}
 　
 　#sidebar {
 　 width: double(5px);
 　}        
</code></pre></li>
</ol>


<h1>参考链接</h1>

<p>SASS用法指南<a href="http://www.ruanyifeng.com/blog/2012/06/sass.html">http://www.ruanyifeng.com/blog/2012/06/sass.html</a></p>

<h1>后续遇到的问题</h1>

<ol>
<li><p>sass 普通命令能使用 但是监听文件就报错</p>

<pre><code> K:sass maizhikun$ sass --watch _bootstrap.scss:../CSS/Haplox.css
 &gt;&gt;&gt; Sass is watching for changes. Press Ctrl-C to stop.
 I, [2015-10-21T09:34:38.749464 #4396]  INFO -- : Celluloid 0.17.2 is running in BACKPORTED mode. [ http://git.io/vJf3J ]
 ArgumentError: wrong number of arguments (2 for 1)
 Use --trace for backtrace.
</code></pre>

<p> 然后Mac搜索Gemfile,居然在握的octopress文件夹里&hellip;.</p></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Grunt玩Bootstrap]]></title>
    <link href="http://mzkmzk.github.io/blog/2015/10/16/grunt_bootstrap/"/>
    <updated>2015-10-16T11:37:40+08:00</updated>
    <id>http://mzkmzk.github.io/blog/2015/10/16/grunt_bootstrap</id>
    <content type="html"><![CDATA[<!--more-->


<h1>0 前面的工作</h1>

<ol>
<li>安装node</li>
<li><p><code>sudo npm install -g grunt-cli</code>全局环境中安装grunt-cli;</p>

<pre><code> K:bootstrap-sass-3.3.5 maizhikun$ sudo npm install -g grunt-cli
 Password:
 /usr/local/bin/grunt -&gt; /usr/local/lib/node_modules/grunt-cli/bin/grunt
 grunt-cli@0.1.13 /usr/local/lib/node_modules/grunt-cli
 ├── resolve@0.3.1
 ├── nopt@1.0.10 (abbrev@1.0.7)
 └── findup-sync@0.1.3 (lodash@2.4.2, glob@3.2.11)
</code></pre></li>
<li><p>cd 到bootstrap目录 安装依赖关系 根据package.json,<code>sudo npm install</code></p></li>
<li><p>grunt dist(编译js和css到/dist/目录)</p>

<p> 失败,显示:</p>

<pre><code> K:bootstrap-sass-3.3.5 maizhikun$ grunt dist
 grunt-cli: The grunt command line interface. (v0.1.13)

 Fatal error: Unable to find local grunt.

 If you're seeing this message, either a Gruntfile wasn't found or grunt
 hasn't been installed locally to your project. For more information about
 installing and configuring grunt, please see the Getting Started guide:

 http://gruntjs.com/getting-started 
</code></pre>

<p> 我更新了下num<code>sudo npm update -g npm</code></p>

<p> 重新安装全局grunt<code>sudo npm install -g grunt-cli</code></p>

<p> 查找网上资料执行了<code>sudo npm install grunt --save-dev</code><a href="http://stackoverflow.com/questions/15483735/fatal-error-unable-to-find-local-grunt-when-running-grunt-command">参考</a></p>

<p> 再执行grunt dist</p>

<pre><code> K:bootstrap-sass-3.3.5 maizhikun$ sudo grunt dist
 A valid Gruntfile could not be found. Please see the getting started guide for
 more information on how to configure grunt: http://gruntjs.com/getting-started
 Fatal error: Unable to find Gruntfile.
</code></pre>

<p> 傻傻的我最后 发现原来少了Gruntfile文件,因为我下载的Bootstrap是sass版本的.要下载源码版本才可以.但是下载原版后发现Gruntfile太庞大了.所以先放下.以后再去了解.现在先使用Grunt作为压缩JS工具所用.</p></li>
</ol>


<h1>1 在项目中使用</h1>

<ol>
<li>下载Bootstrap源码版本,拷贝<code>package.json</code>,<code>Gruntfile.js</code>.到所需目录下</li>
<li><code>npm install</code> 加载node_modules;</li>
<li><p>压缩JS 修改Gruntfile.js</p>

<pre><code> module.exports = function (grunt) {
 // 项目配置
 grunt.initConfig({
     pkg: grunt.file.readJSON('package.json'),
     uglify: {
         options: {
             banner: '/*! &lt;%= pkg.file %&gt; &lt;%= grunt.template.today("yyyy-mm-dd") %&gt; */\n'
         },
          build: {
             src: ['src/*.js','src/bootstrap/*.js'],
             dest: 'Haplox.min.js'
         }
     }
 });
  // 加载提供"uglify"任务的插件
  grunt.loadNpmTasks('grunt-contrib-uglify');
  // 默认任务
  grunt.registerTask('default', ['uglify']);
  }
</code></pre></li>
<li><p>grunt即可.</p></li>
</ol>


<h1>参考资料</h1>

<p>详细从0开始<a href="http://www.cnblogs.com/yexiaochai/p/3603389.html">http://www.cnblogs.com/yexiaochai/p/3603389.html</a></p>

<p>bootstrap中文<a href="http://v3.bootcss.com/getting-started/">http://v3.bootcss.com/getting-started/</a></p>

<p>中文Grunt文档<a href="http://www.gruntjs.net/getting-started">http://www.gruntjs.net/getting-started</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Wordpress入门]]></title>
    <link href="http://mzkmzk.github.io/blog/2015/10/14/wordpress_study/"/>
    <updated>2015-10-14T11:37:40+08:00</updated>
    <id>http://mzkmzk.github.io/blog/2015/10/14/wordpress_study</id>
    <content type="html"><![CDATA[<!--more-->


<h1>1 需要实现的功能</h1>

<ol>
<li>升级wordpress</li>
<li>如何写一套自己的主题</li>
<li>wordpress如何使用React</li>
<li>迁移wordpress</li>
</ol>


<h1>4 迁移wordpress</h1>

<ol>
<li>导入数据库</li>
<li>在wp-login.php配置新的数据库信息</li>
<li>在pdf-options填写siteurl为当前url</li>
</ol>


<h1>5 升级wordpress</h1>

<p>自动升级失败->手动点击更新失败</p>

<p>自己去下载覆盖</p>

<ol>
<li>删除wp-admin和wp-includes</li>
<li>其余覆盖于合并</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[前端组件积累]]></title>
    <link href="http://mzkmzk.github.io/blog/2015/10/14/qian_duan_summing_up/"/>
    <updated>2015-10-14T11:37:40+08:00</updated>
    <id>http://mzkmzk.github.io/blog/2015/10/14/qian_duan_summing_up</id>
    <content type="html"><![CDATA[<!--more-->


<h1>WEB</h1>

<ol>
<li>WEB实现类似文件夹效果<a href="http://photonkit.com/">http://photonkit.com/</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Docker入门]]></title>
    <link href="http://mzkmzk.github.io/blog/2015/10/14/Docker_start/"/>
    <updated>2015-10-14T11:37:40+08:00</updated>
    <id>http://mzkmzk.github.io/blog/2015/10/14/Docker_start</id>
    <content type="html"><![CDATA[<!--more-->


<h1>1 需要实现的功能</h1>

<ol>
<li>新版htmlDocker部署到服务器上</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RESTful设计]]></title>
    <link href="http://mzkmzk.github.io/blog/2015/10/12/study_restful/"/>
    <updated>2015-10-12T11:37:40+08:00</updated>
    <id>http://mzkmzk.github.io/blog/2015/10/12/study_restful</id>
    <content type="html"><![CDATA[<!--more-->


<ol>
<li>协议: 必须使用https.</li>
<li>域名: <a href="https://api.example.com">https://api.example.com</a> or <a href="https://example.org/api.">https://example.org/api.</a></li>
<li>版本: <a href="https://api/example.com/v1.">https://api/example.com/v1.</a></li>
<li>路径:不能有动词,只有名次,而且名词往往和数据库表对应.</li>
<li><p>HTTP动词: 括号里对应的SQL命令</p>

<p> 5.1. GET (SELECT): 从服务器取出资源(一项或多项).</p>

<p> 5.2. POST (CREATE): 在服务器新建一个资源.</p>

<p> 5.3. PUT (UPDATE): 在服务器更新资源(客户端提供改变的属性).</p>

<p> 5.4. PATCH (UPDATE): 在服务器更新资源(客户端提供改变的属性).</p>

<p> 5.5 DELETE (DELETE): 从服务器删除资源.</p>

<p> 5.6 HEAD: 获取资源的元数据(不常用).</p>

<p> 5.7 OPTIONS: 获取信息,关于资源的哪些属性是客户端可以改变的.</p>

<p> 例子</p>

<pre><code> GET /zoos：列出所有动物园
 POST /zoos：新建一个动物园
 GET /zoos/ID：获取某个指定动物园的信息
 PUT /zoos/ID：更新某个指定动物园的信息（提供该动物园的全部信息）
 PATCH /zoos/ID：更新某个指定动物园的信息（提供该动物园的部分信息）
 DELETE /zoos/ID：删除某个动物园
 GET /zoos/ID/animals：列出某个指定动物园的所有动物
 DELETE /zoos/ID/animals/ID：删除某个指定动物园的指定动物
</code></pre></li>
</ol>


<p>6.0 过滤信息</p>

<pre><code>?limit=10：指定返回记录的数量
?offset=10：指定返回记录的开始位置。
?page=2&amp;per_page=100：指定第几页，以及每页的记录数。
?sortby=name&amp;order=asc：指定返回结果按照哪个属性排序，以及排序顺序。
?animal_type_id=1：指定筛选条件
</code></pre>

<p>7.0 状态吗</p>

<pre><code>200 OK - [GET]：服务器成功返回用户请求的数据，该操作是幂等的（Idempotent）。
201 CREATED - [POST/PUT/PATCH]：用户新建或修改数据成功。
202 Accepted - [*]：表示一个请求已经进入后台排队（异步任务）
204 NO CONTENT - [DELETE]：用户删除数据成功。
400 INVALID REQUEST - [POST/PUT/PATCH]：用户发出的请求有错误，服务器没有进行新建或修改数据的操作，该操作是幂等的。
401 Unauthorized - [*]：表示用户没有权限（令牌、用户名、密码错误）。
403 Forbidden - [*] 表示用户得到授权（与401错误相对），但是访问是被禁止的。
404 NOT FOUND - [*]：用户发出的请求针对的是不存在的记录，服务器没有进行操作，该操作是幂等的。
406 Not Acceptable - [GET]：用户请求的格式不可得（比如用户请求JSON格式，但是只有XML格式）。
410 Gone -[GET]：用户请求的资源被永久删除，且不会再得到的。
422 Unprocesable entity - [POST/PUT/PATCH] 当创建一个对象时，发生一个验证错误。
500 INTERNAL SERVER ERROR - [*]：服务器发生错误，用户将无法判断发出的请求是否成功。
</code></pre>

<p>更全<a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html">http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html</a></p>

<p>8.0 错误处理</p>

<pre><code>{
error: "Invalid API key"
}
</code></pre>

<p>9.0 返回结果</p>

<pre><code>GET /collection：返回资源对象的列表（数组）
GET /collection/resource：返回单个资源对象
POST /collection：返回新生成的资源对象
PUT /collection/resource：返回完整的资源对象
PATCH /collection/resource：返回完整的资源对象
DELETE /collection/resource：返回一个空文档
</code></pre>

<p>10.0 Hypermedia API</p>

<p>RESTful的API最好做到Hypermedia API,既返回结果中提供链接,连向其他API方法,使得用户不查文档,也知道下一步该作什么.</p>

<p>比如，当用户向api.example.com的根目录发出请求，会得到这样一个文档。</p>

<pre><code>{"link": {
    "rel":   "collection https://www.example.com/zoos",//路径与本API的关系
    "href":  "https://api.example.com/zoos", //API路径
    "title": "List of zoos", //标题
    "type":  "application/vnd.yourformat+json" //返回类型
}}
</code></pre>

<p>例子<a href="https://api.github.com/">https://api.github.com/</a></p>

<p>11.0 其他</p>

<p>API身份证认真使用Oauth 2.0<a href="http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html">http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html</a>
尽量使用JSON</p>

<h3>参考链接</h3>

<p>阮一峰: <a href="http://www.ruanyifeng.com/blog/2014/05/restful_api.html">http://www.ruanyifeng.com/blog/2014/05/restful_api.html</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Laravel 命令]]></title>
    <link href="http://mzkmzk.github.io/blog/2015/10/12/laravel-order/"/>
    <updated>2015-10-12T11:37:40+08:00</updated>
    <id>http://mzkmzk.github.io/blog/2015/10/12/laravel-order</id>
    <content type="html"><![CDATA[<!--more-->


<ol>
<li><p>命令行爽Eloquent</p>

<pre><code> php artisan tinker
</code></pre>

<p> 这样爽的好处?可以看到返回的类型和执行sql</p>

<pre><code> App\Models\Ready_Sample_Model::all();
 select * from `ready_samples`
 =&gt; Illuminate\Database\Eloquent\Collection {#895
 all: [
App\Models\Ready_Sample_Model {#896
  id: 2646,
  ....
</code></pre></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Laravel Eloquent]]></title>
    <link href="http://mzkmzk.github.io/blog/2015/10/05/laravel-eloquent/"/>
    <updated>2015-10-05T11:37:40+08:00</updated>
    <id>http://mzkmzk.github.io/blog/2015/10/05/laravel-eloquent</id>
    <content type="html"><![CDATA[<!--more-->


<p>命令行爽Eloquent</p>

<pre><code>cd 项目跟目录
php artisan tinker
</code></pre>

<p>这样爽的好处?可以看到返回的类型和执行sql</p>

<pre><code>App\Models\Ready_Sample_Model::all();
select * from `ready_samples`
=&gt; Illuminate\Database\Eloquent\Collection {#895
 all: [
   App\Models\Ready_Sample_Model {#896
     id: 2646,
     ....
</code></pre>

<p>Model排序</p>

<pre><code>Ready_Sample_Model::all()-&gt;sortByDesc('updated_at')
Ready_Sample_Model::all()-&gt;sort('updated_at')
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[疯狂Html+CSS+JS 中JS总结]]></title>
    <link href="http://mzkmzk.github.io/blog/2015/10/05/amazeing-js/"/>
    <updated>2015-10-05T11:37:40+08:00</updated>
    <id>http://mzkmzk.github.io/blog/2015/10/05/amazeing-js</id>
    <content type="html"><![CDATA[<!--more-->


<h1>0 总结</h1>

<p>本书的JS</p>

<ol>
<li>第一章有讲语法有挺多常见的坑点和原理解释很不错</li>
<li>第二章DOM编程讲述了挺多API</li>
<li>第三章事件处理机制其实对事件中的this关键字和事件传播顺序讲解还不错</li>
<li>第四章WebStorage本地存储例子鲜明</li>
<li>第五章Worker应付复杂的js操作</li>
<li>第六章客户端通信WebSocket挺有用,可以实现用户与用户在浏览器中互动</li>
</ol>


<h1>1. JavaScript语法</h1>

<h2>1.1 执行js代码</h2>

<ol>
<li>javascript:alert(&lsquo;执行js&rsquo;);</li>
<li><code>&lt;script&gt;alert("执行js")&lt;/script&gt;</code></li>
</ol>


<h2>1.2 变量赋值</h2>

<pre><code>var a = 1;//显式
a =1; //隐式
</code></pre>

<h2>1.3 全局变量与局部变量</h2>

<pre><code>...
var scope = "全局变量";
function test(){
    alert(scope); // undefiend
    var scope = "局部变量";
    alert(scope); // 局部变量
}
</code></pre>

<p>因为全局变量被局部变量覆盖了.虽然局部变量的scope还没赋值,但是已经在方法里&#8221;占&#8221;上位置了.</p>

<p>但如果把局部变量的var删了,就会先输出全局变量后输出局部变量,因为没有var在方法里给局部变量&#8221;占&#8221;位置;</p>

<h2>1.4 浮点数</h2>

<pre><code>var a =.333
var b = a * 5;
alert(b);
</code></pre>

<p>得出的结果是 1.66499999999999999</p>

<p>所以在js中判断浮点数是否相等 建议判断两者的差值是否小于一个足够的数(例如0.0000000000001)</p>

<h2>1.5 字符串</h2>

<p>js中没有字符类型变量 &ldquo;&#8221;与&#8217;&lsquo;一致</p>

<pre><code>var s ="abcdefg"

//b = "def"
b = s.slice(3, -1);
</code></pre>

<h2>1.6 字符串的正则表达式方法中</h2>

<ol>
<li>match()返回匹配的字符串(数组或null),可加/g进行全局匹配多个</li>
<li>search()返回匹配的索引值 单个</li>
</ol>


<h2>1.7 undefined和null</h2>

<pre><code>null == undefined //true

null === undefined //false
</code></pre>

<p>undefined 是没设值</p>

<p>null则是设定了为null值</p>

<h2>1.8 运算符</h2>

<pre><code>//逗号运算符 取最右返回值
a = (b =5 , c = 7 , d =56) //a =56

a = void(b =5 , c = 7 , d =56) //a = undefined
</code></pre>

<h2>1.9 typeof和instanceof</h2>

<p>typeof 用来获得 实例类型 :</p>

<pre><code>typeof("123"); //string
</code></pre>

<p>instanceof 判断变量是否为某类的实例</p>

<pre><code>var a = [4,5];
alert(a instanceof Array); //true
</code></pre>

<h2>1.10 语句</h2>

<p>抛出异常</p>

<pre><code>throw new Error("用户自定义异常"); //一般用于终止程序和返回错误提示是个不错的选择;

try{

}catch(e){
    alert(e.message); // "用户自定义异常"
}
</code></pre>

<p>for in</p>

<pre><code>//这回输出浏览器的所有属性,做浏览器兼容之前可以考虑看看.
for( prop_name in navigator){
    document.wrti(prop_name + " : " + navigator[propname]);
}   
</code></pre>

<p>跳出命名for</p>

<pre><code>outer: 
for(...){
    for(...){
        ...
        continue outer;
    }
}
</code></pre>

<h2>1.11 函数</h2>

<p>js 允许先调用函数 再定义函数</p>

<h3>1.11.1 定义匿名函数</h3>

<pre><code>var show_name = function(name){
    alert(name);
}

show_name("K"); //K
</code></pre>

<p>这样的好处是什么,如果直接定义function 它实际上也是创建了一个对象</p>

<h3>1.11.2 函数既对象</h3>

<pre><code>var hello = function(){...};

hello instanceof Function //true;

hello instanceof Object //true;

alert(heelo) //输出函数源代码
</code></pre>

<h3>1.11.3 调用函数方式的不同</h3>

<ol>
<li>直接调用函数 返回return的值或void</li>
<li>new 函数 得到的都是对象 - -&hellip;&hellip;.</li>
</ol>


<h3>1.11.4 this关键字.</h3>

<p>在函数中使用this.变量 该变量就是函数的实例变量,而非局部变量,无论它在哪里.</p>

<p>函数可依附在类中.如没指定 则依附在winodw对象中</p>

<pre><code>var hello =function(){...}

window.hello();

var p = {
    wark: function(){...}
}
p.wark();
</code></pre>

<h3>1.11.5 函数中的变量有三种</h3>

<pre><code>function Person(){
    //局部变量 只能在函数里访问
    var id ;

    //实例属性 通过对象.访问
    this.age ;

    //类属性 通过Patient.name访问 与static类似
    Person.name ;
}
</code></pre>

<h3>1.11.6 js是一种动态语言,能随时给对象增加属性和方法</h3>

<pre><code>function Student(){ };

var student =new Student();
//动态增加name属性
student.name = 'K';
alert(sutdent.name) //K

Student.age =22 ;
alert(Student.age); //22 类属性也是可以动态添加的
</code></pre>

<h3>1.11.7 调用函数的三种方式</h3>

<ol>
<li><p>直接调用</p>

<pre><code> windows.alert();
 //or
 alert();
</code></pre></li>
<li><p>call()调用</p>

<p> 作用:动态地传入一个函数引用</p>

<pre><code> var each = function(array,fn){
     for(var index in arrary){
         //null表示以window为调用者fn函数
         fn.call(null,index,arrary[index]);
     }
 }

 each([4,20,3] , function(index ,ele){
     alert("第 " + index "个元素是 : " + ele);
 });
</code></pre>

<p> call()调用函数语法为:<code>函数引用.call(调用者,参数1,参数2...)</code></p>

<p> 直接调用函数语法为:<code>调用者.函数(参数1,参数2 ...)</code> = <code>函数.call(调用者,参数1,参数2 ...)</code></p></li>
<li><p>apply()调用</p>

<p> apply和()call()基本相似,区别如下:</p>

<ol>
<li>通过call()调用函数时,括号必须详细列出每个参数</li>
<li><p>通过apply()动态地调用函数时,可以在括号中以<code>arguments</code>来代表所有参数</p>

<pre><code> var myfun = function (a , b){
     alert(a + "  " +b);
 }

 myfun.call(window ,12 ,23); //12 23;

 myfun.apply(window ,[20 , 39]); //20 39

 var example = function (num1 ,num2){
     //直接调用arguments代表调用者(example,this代表example)时的传入的所有参数
     myfun.apply(this,arguments); 
 }
 example(20,40) //20 40 
</code></pre></li>
</ol>
</li>
</ol>


<h3>1.11.8 函数的独立性</h3>

<p>在函数A中可以定义函数B,但是函数B还是独立于函数A</p>

<pre><code>function Person(name){
    this.name = name;

    this.info = function(){
        alert(this.name);
    }
}   

var person =new Person('K');
person.info(); //K
var name = 'K_window';

//由于window为调用者 ,this.name访问的是window.name
p.info.call(window); //K_window
</code></pre>

<p>来爽一发猫学狗叫?.</p>

<pre><code>function Dog(name,bark){
    this.name = name;
    this.bark = bark;
    this.info =function(){
        alert(this.name + "  " + this.bark);
    }
}

function Cat(name){
    this.name =name;
}   

var dog = new Dog("K","汪汪!");
var cat = new Cat("K_2");
dog.info.call(cat); //K_2 undefined
</code></pre>

<h3>1.11.9 参数传递方式</h3>

<p>和JAVA一样 都是值传递拉~.</p>

<p>基本类型</p>

<pre><code>function change(arg){
    arg =10 ;
    alert(arg);
}
var x = 5;
alert(x); //5
change(x); //10
alert(x); //5
</code></pre>

<p>复合类型</p>

<pre><code>function change(person){
    person.age = 10;
    alert(person.age);
    person = null;
}

var person = {age : 5};
alert(person.age); //5
change(person); //10
alert(person.age); // 10
alert(person); // []object Object]
</code></pre>

<p>复合类型的传递为值传递,原person和参数person指向同一javascript对象,所以当改变age的时候,是在改变javascript对象的age,但是参数person赋值为null,原person并无改变.</p>

<h3>1.11.10 空参数</h3>

<pre><code>function text(person){
    alert( typeof parson);
}

text(); //undefined
</code></pre>

<p>所以对于弱类型,方法重载是无作用的,因为js会把空参数当做undefined传递进去;</p>

<p>同名函数,后面出现的会覆盖前面的,无论参数个数是多少.</p>

<h3>1.11.11 对象和关联数组</h3>

<p>javascript和Map有点类似,当key为对象,value为函数,该该函数就是对象的方法,当key为对象,value为基本类型,则该基本类型为对象的属性.(以上为便于理解,切勿细琢)所以访问属性时,可以obj.propName也可以obj[propName].</p>

<p>但有时候我们只能用obj[propName],因为.propName不能把propName当做变量处理,而是把他当成&#8217;propName&#8217;字符串</p>

<pre><code>function Person(name){
    this.name =name;
    this.info = function(){
        alert(K);
    }
}

var person = new Person("K");
//遍历person属性
for (propName in person){
    alert(p[propName]);//alet K info源代码 假如此处用p.propName则undefined,因为Person无'propName'变量.
}
</code></pre>

<h3>1.11.12 继承和prototype</h3>

<p>在一个类(函数)中定义一个函数会导致</p>

<ol>
<li>性能低下:每次new一个类 都会生成一个函数</li>
<li><p>函数中若引用类的局部变量会产生闭包 导致局部变量一直存在</p>

<pre><code> function Person(){
     var local = "局部变量"
     this.info = function(){
         //产生闭包
         alert(local);
     }
 }

 var person = new Person();
 person.ifno(); // 局部变量  
</code></pre></li>
</ol>


<p>解决方案:prototype</p>

<p>增加了prototype属性的类可视为继承了原先的类(伪继承)</p>

<pre><code>function Person(){...}

var person = new Person();

//person.wark(); 程序报错wark不存在
Person.prototype.wark = function(){...}

person.wark(); //ok
</code></pre>

<p>在prototype之前实例化的类会具有wark方法吗? 有的,因为prototype这样并不会产生一个新的类,而是直接动态的往Person里加函数.</p>

<h2>1.12 创建对象三种方式</h2>

<pre><code>//(单身汪别说我不教你)
</code></pre>

<ol>
<li><p>new关键字调用构造器创建对象</p>

<pre><code> function Person(name){...}
 var person_1 = new Person();
 var person_2 = new Person('K'); //js不存在方法重载,空参数undefined顶替
</code></pre></li>
<li><p>使用Object直接创建对象</p>

<pre><code> var my_obj = new Object();
 my_ojb.name = 'K';
 my_obj.handsome = function(){...}

 function text(){...}
 my_obj.text = text;//不要添加(),不然会认为是调用方法
</code></pre></li>
<li><p>JSON创建对象</p>

<pre><code> ver person = {
     name : 'K',
     school : ['ChangAn','TianJin'],
     girl_friends :[
         {
             name : 'Haski',
             age : 11
         },
         {
             name : 'Samoyed',
             age : '8'
         }
     ]
 }

 alert(person.girl_friends[0].name); //Haski
</code></pre></li>
</ol>


<h1>2 DOM编程</h1>

<p>DOM操作其实JQuery已经做得很好了,这里简单补充一下原生JS的知识</p>

<p>HTML文档中只有一个根节点</p>

<h2>2.1 访问HTML元素</h2>

<ol>
<li>id getElementById(&lsquo;id&rsquo;); or getElementsByName(&lsquo;name&rsquo;);</li>
<li><p>根据节点关系</p>

<pre><code> Node parentNode: 返回父节点
 Node previousSibling: 返回前一个兄弟节点
 Node nextSibling: 饭后后一个兄弟节点
 Node[] childNodes 返回当前节点的所有节点
 Node[] getElementsByTagName('标签名称'): 返回当前节点具有制定标签的子节点
 //注意ol标签的子标签IE8和其他浏览器不一样(其他浏览器会把ol下的li和其后面的空白分别当成2个节点,IE8则不会)
</code></pre></li>
</ol>


<h2>2.2 增加HTML函数</h2>

<ol>
<li>document.createElement(&ldquo;标签名&rdquo;);</li>
<li>复制节点 var node = ul.firstChild.nextSibling.cloneNode(boolean),boolean为true时,复制所有所有后代节点.false则仅复制当前节点.clone了节点以后还要找一个节点添加进去.</li>
</ol>


<h2>2.3 添加节点</h2>

<ol>
<li>appendChild(Node);添加为当前节点的最后一个子节点</li>
<li>inserBefore(newNode,refNode);在refNode前添加newNode</li>
<li>replaceChild(newChild,oldChild);替换节点</li>
<li>增加select选项 new Option(text,value,defaultSelected,selected);</li>
</ol>


<h2>2.4 删除节点</h2>

<ol>
<li>removeChild(oldNode);</li>
</ol>


<h2>2.5 window对象</h2>

<ol>
<li>返回上一个页面: back()</li>
<li>window.href: 当前url</li>
<li>window.width: 屏幕横向分辨率</li>
<li>window.height: 屏幕纵向分辨率</li>
<li><p>遍历window.screen,包含所以屏幕属性</p>

<pre><code> for(var propName in window.screen){
     alert(propName+":" +screent[propname]);
 }
</code></pre></li>
<li><p>cofrim(&lsquo;标题&rsquo;); 能弹出是否确认的提示框</p></li>
<li>prompt(&lsquo;标题&rsquo;); 能弹出一个文本输入框输入.</li>
<li><p>定时器:setInterVal,clearInterval()</p>

<pre><code> var timer;
 var cur = new Date().getTime();
 var setTime = function(){
     document.getElementById("tm").innerHTML = new Date().toLocationString();
     if(new Date().getTime- cur &gt; 60 *1000){
         clearInterval(timer);
     }
 }
 //每1S执行一次,执行了60次就暂停
 timer = window.setInterval("setTime()",1000);
</code></pre></li>
</ol>


<h2>2.6 navigator和地理位置</h2>

<p>navigator汉堡浏览器所有信息,遍历循环获取信息</p>

<pre><code>for(var propName in window.navigator){
    alert(propName + ":" + window.navigator[propName]);
}   
</code></pre>

<p>HTML5新增geolocation属性</p>

<p>Geolocation提供的方法</p>

<ol>
<li>getCurrentPosition(onSuccess,onError,options)</li>
<li>int watchCurrentPostion(OnSuccess,onError,options),周期性调用getCurrentPosition,返回的int代表这个&#8221;监听器&#8221;的ID,用来clearWatch(watchID)取消监听</li>
<li>clearWatch(watchID),用于取消watchCurrentPosition</li>
</ol>


<p>上面的前两个方法的options参数是一个对象,可包含3个变量</p>

<ol>
<li>enabelHighAccuracy(是否制定高精度地理位置)</li>
<li>tiemout 设置超时时长</li>
<li>maximumAge,设置缓存时间</li>
</ol>


<p>例子:</p>

<pre><code>var geoHandler = function(position){
    var geoMsg = "用户地址位置是 : &lt;br/&gt;"
    geoMsg += "timestamp属性为 :" + position.timestamp + "&lt;br/&gt;"//获取位置的时间
    var cords =position.coords;
    for(var prop in coords ){
        geoMsg += prop + ": " + coords[prop] +"&lt;br/&gt;"//经纬度,移动速度等
    }
    document.writeln(geoMsg);
}

var errorHandler = function(error){
    var errMsg = {
        1: '用户拒绝了位置服务'
        2: '无法获取地址位置信息'
        3: '获取地理位置信息超时'
    };
    alert(error[error.code]);
}

navigator.geolocation.getCurrentPosition(geoHandler
, errorHandler
, {
    enableHighAccuracy:true,
    maximuAge:1000
});
</code></pre>

<h2>2.7 HTML5新增浏览器分析</h2>

<p>实现该功能主要通过performance对象</p>

<p>其中的(PerformanceTiming)timing属性包含加载时间相关的属性</p>

<p>另外(PerformanceNavigation)navigation,主要属性有</p>

<p>type :</p>

<pre><code>TYPE_NAVIGATE(数值为0): 超链接/输入url
TYPE_RELOAD(1): 重新加载方式,diaoyonglocation.reload()等
TYPE_BACK_FORWARD(2): 通过浏览器的前进方式
TYPE_RESERVED(255): 未知方式
</code></pre>

<p>redirectCount: 重定向次数</p>

<h1>3 事件处理机制</h1>

<h2>3.1 常见事件</h2>

<ol>
<li>onabort: 图片加载终端</li>
<li>onblur: 失去焦点</li>
<li>onchange: 表单域更改</li>
<li>onclick: 点击</li>
<li>onerror: 图片加载出错</li>
<li>onfocus: 获得焦点</li>
<li>onkeydown: 按下鼠标</li>
<li>onkeypress: 当焦点在当前元素上,单击键盘某个键触发</li>
<li>onkeyup: 当焦点在当前元素上,松开某个键触发</li>
<li>onload: 某个对象加载完毕,适用于<code>img</code>,<code>oframe</code>,<code>body</code></li>
<li>onunload: 当某个对象从窗口下卸载触发,适用于<code>img</code>,<code>oframe</code>,<code>body</code></li>
<li>onmousedown: 焦点停留在当前元素上,按下鼠标触发</li>
<li>onmousemore: 当焦点在当前元素上,鼠标移动到该元素</li>
<li>onmouseout: 鼠标移出当前元素触发</li>
<li>onmouseover: 鼠标移动到该元素触发</li>
<li>onmouseup: 焦点在当前元素,松开鼠标时触发</li>
<li>onreset: 重置表单时触发</li>
<li>onsubmit: 表单提交触发</li>
</ol>


<h2>3.2 事件处理和this</h2>

<pre><code>p.info = function(){
    alert(this.name);
}
document.getElementById("bt").onclick = p.info//this指向'bt'控件
document.getElementById("bt").onclick = new function (){ p.info();} //this总是指向p
</code></pre>

<p>注意表单设置id为x和name为y时候,相当于表单创建了x属性和y属性,所以id和name不能是关键字submit等</p>

<h2>3.3 DOM</h2>

<p>创建监听事件</p>

<p>objectTarget.addEventListener(&ldquo;eventType&rdquo;,handler,capture),第一个参数表示绑定的事件,如click、keypress之类的,第二个制定绑定的函数,第3个位boolean,true表示监听捕获阶段,false表示监听冒泡阶段</p>

<p>objectTarget.removeEventListener(&ldquo;eventType&rdquo;,handler,captureFlag): 删除绑定事件</p>

<p>捕获状态阶段的绑定事件先执行,事件冒泡状态阶段的绑定事件后执行.
捕获状态阶段从外往内触发,事件冒泡状态阶段从内往外触发.</p>

<p>绑定例子</p>

<pre><code>var got_click = function (event){
    for ( event_one in event){
        alert(event_one + "  : " + event[event_one]);
    }
}   

document.getElementByID("test").addEventListener("cilck",got_click,true);
</code></pre>

<p>阻止事件传播</p>

<pre><code>event.stopPropagation();
</code></pre>

<p>取消事件的默认行为,如跳转页面等,但不会阻止事件传播.</p>

<pre><code>event.preventDefault();
</code></pre>

<h3>3.3.1转发事件</h3>

<p>DOM提供了dispathEvent方法用于事件转发,该方法属于Node</p>

<p>target.dispathEvent(Event event),将event转发到target上</p>

<p>DOM的dispath()必须转发人工合成的Event事件</p>

<p>document.createEvent(String type),tpy参数用于指定事件类型,eg:普通事件Events,UI事件UIEvents,鼠标事件:MouseEvents</p>

<p>初始化事件</p>

<pre><code>initEvent(具体参数...)

initUIEvent(具体参数...)

intMouseEvent(具体参数...)

//例子

&lt;input id="bt1"&gt;
&lt;input id="bt2"&gt;
...

var rd =function(evt){
    alert("事件冒泡阶段: " + evt.currentTarget.value +"被点击了");
    var e =document.createEvent("Evnets");
    e.initEvent("click",true,false);//true表示是否支持冒泡,false表示是否有默认行为
    document.getElementById("bn2").dispathEvent(e);
}
var go_click = function (evt){
    alert("事件冒泡阶段: " + evt.currentTarget.value);
}

document.getElementById("bn1").addEventListener("click",rd,false);

document.getElementById("bn2").addEventListener("click",go_click,false);;

//点解按钮一结果
alert(事件冒泡阶段: 按钮一被点击了);
alert(事件冒泡阶段:按钮2);
</code></pre>

<p>点击按钮1,按钮执行了前面按钮一被点击了提示语句后,将点击事件转给了按钮2,按钮2执行自身的点击事件.</p>

<h1>4 本地存储与离线应用</h1>

<h2>4.1 Web Storage</h2>

<p>使用理由之一Cookie的局限性:</p>

<ol>
<li>Cookie大小被限制为4KB</li>
<li>Cookie会包含在每次HTTP请求中</li>
<li>Cookie网络传输未加密(除非整个应用都使用SSL)</li>
</ol>


<p>Web Storage分两种</p>

<p>Session Storage: 生命周期与用户Session一致(用户Session是指:用户从访问网址到离开网址/关闭浏览器)</p>

<p>Local Storage: 保存在用户的磁盘中,失效的方式为用户/程序显示删除.</p>

<p>Web Storage的方法有</p>

<ol>
<li>length: 返回key-value对数</li>
<li>key(index): 返回第index个key</li>
<li>getItem(key): 获取key对应的value</li>
<li>set(key,value): 设置key-value</li>
<li>removeItem(key): 删除key-value</li>
<li>clear(): 清除所有key-value</li>
</ol>


<p>Web Storage包含在window对象中</p>

<p>当value为对象时,建议用JSON存储</p>

<h2>4.2 构建离线应用</h2>

<ol>
<li><p>在html标签中修改</p>

<pre><code> //表明该页使用index.manifest文件
 &lt;html manifest="index.manifest"&gt;
</code></pre></li>
<li><p>index.mainfest文件</p>

<pre><code> CACHE MANIFEST
 //第一行必须为上述字符
 //指定版本号
 #version 1
 //本地缓存资源
 CACHE
 inedx.html
 logo.jpg
 //不缓存的资源
 NETWORK
 *
 //前者表示在线状态使用的资源,后者代表离线状态使用的资源
 FALLBACK
 test.js offline.js
</code></pre></li>
<li><p>Tomcat为例,天津映射文件</p>

<pre><code> &lt;!--conf的web.xml根元素中增加MIME映射--&gt;
 &lt;mine-mapping&gt;
     &lt;extension&gt;manifest&lt;/extension&gt;
     &lt;mine-type&gt;text/cache-mainfest&lt;/mime-type&gt;
 &lt;/mime-mapping&gt;
</code></pre></li>
</ol>


<p>启动应用后,页面可刷新(即使离线状态),并使用离线时候的资源</p>

<h3>4.2.1 判断在线状态</h3>

<p>navigator.onLine属性: true表示在线</p>

<p>online/offline事件: 当在线/离线状态切换时,body上的online/offine事件会被触发,沿着document.body、document和window冒泡</p>

<pre><code>window.addEventListener("offline",function(){
    alert("离线状态")
},true);
if(navigator.onLine){
    alert("在线");
}
</code></pre>

<h3>4.2.2 applicationCache对象</h3>

<p>js可通过applicationCache控制离线缓存.</p>

<p>status属性:</p>

<ol>
<li>UNCACHE: 主机没开启离线功能.</li>
<li>IDLE: 空闲状态.</li>
<li>CHECKING: 正在检查本地manifest和服务器中manifest的差异</li>
<li>DOWNLOADING: 正在下载需要的缓存数据</li>
<li>OBSOLETE: 缓存已经过期</li>
</ol>


<p>常用方法</p>

<ol>
<li>void update(): 强制检查服务器的mainfest文件是否有更新</li>
<li><p>void swapCache(): 更新缓存,只能在applicationCache的updateReady事件被触发时调用.</p>

<pre><code> setInterval(function(){
     applicationCache.update()
 },2000);

 applicationCache.onupdateready = function(){
     if(confirm("已从远程服务器下载了需要的缓存,是否更新?")){
         applicationCache.swapCache();
         location.reload();
     }
 }
</code></pre>

<h3>4.2.3 离线应用的事件与监听</h3></li>
</ol>


<p>访问html页面过程</p>

<ol>
<li>浏览器请求index.html</li>
<li>服务器返回index.html</li>
<li>浏览器页面是否制定manifest属性,若制定,触发checking事件,检查服务器中的manifest文件是否存在,不存在则触发error事件,不会制定第六部及其后续步骤</li>
<li>浏览器解析index.html,请求该页其他资源.</li>
<li>服务器返回所以请求</li>
<li>浏览器处理mainfest文件,重新请求manifest文件中的所以页面,包括index.html页面,前面下载过的资源,扔会再下一遍.</li>
<li>服务器返回所以要求被要求缓存的资源</li>
<li>浏览器开始下载需要在本地缓存的资源,开始下载时触发ondownloading事件,在下载过程中不断触发onprogress事件.以便开发人员了解下载进度.</li>
<li>下载完成后触发oncache事件.缓存完成</li>
</ol>


<p>当用户再访问index.html时,前面1~5完全相同,接下来检测mainfest文件是否有改变.</p>

<ol>
<li>没有改变触发onnoupdate事件,结束.</li>
<li>mainfest改变,执行第7,8部,当所以文件本地缓存下载完毕后,浏览器触发onupdateready事件,而不会触发oncached事件.</li>
</ol>


<h1>5 使用worker创建多线程</h1>

<p>worker中无法使用DOM、alert等与界面有关的操作.</p>

<p>使用理由:防止js阻塞主线程的js运行</p>

<p>WorkerAPI</p>

<ol>
<li>onmessage: 获取前台js提交过来的数据</li>
<li>postMessage(data): 前台js通过postMessage触发Worker对象的onmessage事件.</li>
<li>importScripts(urls),导入多个js,importScripts(&ldquo;a.js&rdquo;,&ldquo;b.js&rdquo;);</li>
<li>sessionStorge/localStorage: 使用Worker操作Storage本地存储</li>
<li>Worker: 创建新的Worker对象启动嵌套线程</li>
<li>XMLHttpRequest: Worker使用XMLHttpRequest发送异步请求.</li>
<li>navigator: 与window的location属性类似</li>
<li>location: 与window的location属性相似</li>
<li>self: WorkerGlobalScope对象,代表当前Worker线程自身作用域.调用self的close()结束线程</li>
<li>setTimeout()/seInterval()/eval()/inNaN()/parseInt,等与界面无关的js核心函数,包括Array/Data/Math/Number/Object/String等.</li>
</ol>


<p>写一段找出输入start和end之间素数的线程.</p>

<p>worker.js代码</p>

<pre><code>onmessage =function(event){
    var data =JSON.parse(event.data);
    var start =data.start;
    var end =data.end;
    var result ="";
    search:
    for (var n =start; n &lt;= end :n++){
        if(n%i==0){
            continue search;
        }
        result +=(n+",");
    }
}
postMessage(result);
</code></pre>

<p>网页代码</p>

<pre><code>&lt;input name="start" ...&gt;
&lt;input name="end" ...&gt;
&lt;input type=button inclick="cal();" ...&gt;
...
var car =function(){
    var start = parseInt(document.getElementById("start").value);
    var end = parseInt(document.getElementById("end").value);
    //创建线程
    var cal = new Worker("worker.js");
    var data ={
        "start" : srart,
        "end" : end
    };
    //发送数据
    cal.postMessage(JSON.stringify(data));
    cal.onmessage = function (evnet){
        alert(event);
    }
}
</code></pre>

<p>并行的两条Worker不能互相通信,但Wroker可嵌套.</p>

<h1>6 客户端通信</h1>

<p>WebSocket: 服务器主动推送信息/客户端实时推送数据到服务器</p>

<h2>6.1 跨文档通信</h2>

<p>window对象新增方法</p>

<ol>
<li>targetWindow.postMessage(message,targetOrigin): 该方法用户向targetWindow中状态的HTML发送信息,targetOrigin表示接收html的域名.</li>
<li><p>onmessage: 调用方法:windows.onmessage =function(event){&hellip;}</p>

<p> event中的属性:</p>

<ol>
<li>data: 数据</li>
<li>orgin: 发送消息window的源域名</li>
<li>lastEventID: 返回发送消失时间的ID</li>
<li>source: 返回发送消息的窗口</li>
</ol>
</li>
</ol>


<p>html想发送要做</p>

<ol>
<li>获取接收消息的window对象</li>
<li>调用接收消息的window对象的postMessage(any message)方法</li>
</ol>


<p>html想接收要做</p>

<ol>
<li>本html绑定事件window.message = function(event){&hellip;};</li>
</ol>


<p>跨文档消息传递</p>

<pre><code>//source.html
var targetWin = window.open("接收方url",'_blank','windth=400,height=300');

targetWin.onload =function(){
    targetWin.postMessage("传输消息","接收方域名");
}

window.onmessage =function(event){
    //忽略其他域名发送的消息
    if(event.orgin !="指定域名"){
        return ;
    }
    alert(event.data);
}

//接收页面.html
window.onmessage = function(event){
    //忽略其他域名发送的消息
    if(event.orgin !="指定域名"){
        return ;
    }
    alert("接收到消息拉!"+event.data);
    event.source.postMessage("回传消息",event.origin);
}
</code></pre>

<p>结果:</p>

<p>alert(接收到消息拉!传输消息);</p>

<p>alert(回传消息);</p>

<p>注意!一定要判断发送方的域名!!!!!一定要判断发送方的域名!!!!!一定要判断发送方的域名!!!!!</p>

<h3>6.2 WebSocket与服务器通信</h3>

<p>以前方案:</p>

<ol>
<li>周期发送请求</li>
<li>页面使用隐藏窗口与服务器长连接</li>
</ol>


<p>WebSocket方法</p>

<ol>
<li>send(&ldquo;数据&rdquo;);向服务器发送数据.</li>
<li>close();关闭该WebSocket.</li>
</ol>


<p>WebSocket监听事件</p>

<ol>
<li>onopen: 当WebSocket建立网络连接触发该.</li>
<li>onerror: 网络连接错误</li>
<li>onclose: WebScokt被关闭触发</li>
<li>onmessage: WebSocket接收到服务器数据时</li>
</ol>


<p>WebSocket属性</p>

<ol>
<li><p>readyState</p>

<p> 1.1 CONNECTING(0): WebSocket正在尝试连接</p>

<p> 1.2 OPEN(1): 已经连接</p>

<p> 1.3 CLOSING(2): 正在关闭连接</p>

<p> 1.4 CLOSED(3): 已经关闭连接</p></li>
</ol>


<p>WebSocket与服务器通信步骤</p>

<ol>
<li>WebSocket.Constructor(url,[DOMString protocols]);创建WebSocket对象</li>
<li>发送信息: WebSocket对象的send()</li>
<li>接收信息: WebSocket对象的onmessage属性绑定函数;</li>
</ol>


<p>实现客户端多人聊天,JAVA为例</p>

<p>客户端代码:</p>

<pre><code>var web_socket =new WebSocket("ws://域名:端口");

web_socket.onopen =function(){
    web_socket.onmessage =function(event){
        document.getElementById('show').innerHTML += event.data +"&lt;/br&gt;"
    }
};

var sendMsg =function(val){
    var inputElement = document.getElementByID('msg');
    webSocket.send(inputElement.value);
    inputElement.value="";
}

...
</code></pre>

<p>服务端代码</p>

<pre><code>import java.io.*;
import java.net.*;
import java.nio.charset.Charset;
import java.security.MessageDigest;
import java.util.regex.*;
import java.util.*;
import sun.misc.BASE64Encoder;

public class ChatServer
{
    // 记录所有的客户端Soccket
    public static List&lt;Socket&gt; clientSockets
        = new ArrayList&lt;Socket&gt;();
public ChatServer()throws IOException
{
    // 创建ServerSocket，准备接受客户端连接
    ServerSocket ss = new ServerSocket(30000);
    while(true)
    {
        // 接收到客户端连接
        Socket socket = ss.accept();
        // 将客户端Socket添加到clientSockets集合中
        clientSockets.add(socket);
        // 启动线程
        new ServerThread(socket).start();
    }
}
public static void main(String[] args)
    throws Exception{
    new ChatServer();
}
}
class ServerThread extends Thread
{
    private Socket socket;
    public ServerThread(Socket socket)
    {
        this.socket = socket;
    }
    public void run()
    {
    try
    {
        // 得到Socket对应的输入流
        InputStream in = socket.getInputStream();
        // 得到Socket对应的输出流
        OutputStream out = socket.getOutputStream();
        byte[] buff = new byte[1024];
        String req = "";
        // 读取数据，此时建立与WebSocket的"握手"。
        int count = in.read(buff);
        // 如果读取的数据长度大于0
        if(count &gt; 0)
        {
            // 将读取的数据转化为字符串
            req = new String(buff , 0 , count);
            System.out.println("握手请求：" + req);
            // 获取WebSocket的key
            String secKey = getSecWebSocketKey(req);
            System.out.println("secKey = " + secKey);
            String response = "HTTP/1.1 101 Switching Protocols\r\nUpgrade: "
                + "websocket\r\nConnection: Upgrade\r\nSec-WebSocket-Accept: "
                    + getSecWebSocketAccept(secKey) + "\r\n\r\n";
            System.out.println("secAccept = " + getSecWebSocketAccept(secKey));
            out.write(response.getBytes());
        }
        int hasRead = 0;
        // 不断读取WebSocket发送过来的数据
        while((hasRead = in.read(buff)) &gt; 0){
            System.out.println("接收的字节数：" + hasRead);
            /*
                因为WebSocket发送过来的数据遵循了一定的协议格式，
                其中第3个〜第6个字节是数据掩码。
                从第7个字节开始才是真正的有效数据。
                因此程序使用第3个〜第6个字节对后面的数据进行了处理
            */
            for (int i = 0 ; i &lt; hasRead - 6 ; i++ ){
                buff[i + 6] = (byte) (buff[i % 4 + 2] ^ buff[i + 6]);
            }
            // 获得从浏览器发送过来的数据
            String pushMsg = new String(buff
                , 6 , hasRead - 6 , "UTF-8");
            // 遍历Socket集合，依次向每个Socket发送数据
            for (Iterator&lt;Socket&gt; it = ChatServer.clientSockets.iterator()
                ; it.hasNext() ;)
            {
                try
                {
                    Socket s = it.next();
                    // 发送数据时，第一个字节必须与读到的第一个字节相同
                    byte[] pushHead = new byte[2];
                    pushHead[0] = buff[0];
                    // 发送数据时，第二个字节记录发送数据的长度
                    pushHead[1] = (byte) pushMsg.getBytes("UTF-8").length;
                    // 发送前两个字节
                    s.getOutputStream().write(pushHead);
                    // 发送有效数据
                    s.getOutputStream().write(pushMsg.getBytes("UTF-8"));
                }
                catch (SocketException ex)
                {
                    // 如果捕捉到异常，表明该Socket已经关闭
                    // 将该Socket从Socket集合中删除
                    it.remove();
                }
            }
        }
    }
    catch (Exception e)
    {
        e.printStackTrace();
    }
    finally
    {
        try
        {
            // 关闭Socket
            socket.close();
        }
        catch (IOException ex)
        {
            ex.printStackTrace();
        }
    }
}
// 获取WebSocket请求的SecKey
private String getSecWebSocketKey(String req)
{
    //构建正则表达式，获取Sec-WebSocket-Key: 后面的内容
    Pattern p = Pattern.compile("^(Sec-WebSocket-Key:).+",
            Pattern.CASE_INSENSITIVE | Pattern.MULTILINE);
    Matcher m = p.matcher(req);
    if (m.find())
    {
        // 提取Sec-WebSocket-Key
        String foundstring = m.group();
        return foundstring.split(":")[1].trim();
    }
    else
    {
        return null;
    }
}
// 根据WebSocket请求的SecKey计算SecAccept
private String getSecWebSocketAccept(String key)
    throws Exception
{
    String guid = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11";
    key += guid;
    MessageDigest md = MessageDigest.getInstance("SHA-1");
    md.update(key.getBytes("ISO-8859-1") , 0 , key.length());
    byte[] sha1Hash = md.digest();
    BASE64Encoder encoder = new BASE64Encoder();
    return encoder.encode(sha1Hash);
}
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[系统分析师UML项目实战书籍阅读总结]]></title>
    <link href="http://mzkmzk.github.io/blog/2015/10/01/uml_project_book/"/>
    <updated>2015-10-01T11:37:40+08:00</updated>
    <id>http://mzkmzk.github.io/blog/2015/10/01/uml_project_book</id>
    <content type="html"><![CDATA[<!--more-->


<h3>1. UML项目现场</h3>

<p><code>只有平庸的人,才会提出复杂的解决方案</code></p>

<p>UML建模顺序: 流程建模 -> 用例建模 ->领域建模</p>

<p>活动图,用例图,类图的图标名称介绍.</p>

<h3>2. 业务流程建模</h3>

<p>业务流程定义:</p>

<ol>
<li>特定的客户</li>
<li>特定的目标</li>
<li>特定的服务</li>
</ol>


<p>对于不重要的工作,不做活动图</p>

<p>表2-1 活动图用于表示业务流程或系统流程</p>

<table>
<thead>
<tr>
<th> 项目\活动图  </th>
<th> 业务流程                                  </th>
<th> 系统流程                                  </th>
</tr>
</thead>
<tbody>
<tr>
<td> 主要作用      </td>
<td>                   表示企业组织的未来流程   </td>
<td> 表示系统内部的系统流程                     </td>
</tr>
<tr>
<td> 人工操作      </td>
<td> 可能出现人工操作                          </td>
<td> 不会出现人工操作                          </td>
</tr>
<tr>
<td> 生成机时      </td>
<td> 需求分析阶段                                </td>
<td> 系统设计时间                                </td>
</tr>
<tr>
<td> 相关文件      </td>
<td> 收录在系统需求的规格书(SRS)                </td>
<td> 收录在系统设计规格书(SDS)                   </td>
</tr>
<tr>
<td> 绘制者         </td>
<td> 系统分析师                                   </td>
<td> 系统设计师                                   </td>
</tr>
<tr>
<td> 观看者         </td>
<td> 客户/用户(系统设计师也会参考使用)          </td>
<td> 程序设计师                                   </td>
</tr>
<tr>
<td> 粒度            </td>
<td> 一张活动图对应多个用例(即将用例视为黑箱)   </td>
<td> 一张活动图对应一个用例(即将用例视为白盒)   </td>
</tr>
</tbody>
</table>


<p>表2-2 于系统设计时间的活动图和顺序图</p>

<table>
<thead>
<tr>
<th> 项目/图类型  </th>
<th> 活动图(系统流程)                           </th>
<th> 顺序图(对象互动)                               </th>
</tr>
</thead>
<tbody>
<tr>
<td> 主要作用      </td>
<td> 表示系统内部的系统流程                     </td>
<td> 表示系统内部的对象互动                         </td>
</tr>
<tr>
<td> 主要特色      </td>
<td> 凸显流程与控制节点                           </td>
<td> 凸显对象依序调用方法或函数                       </td>
</tr>
<tr>
<td> 生成时机      </td>
<td> 高级的系统设计时间                           </td>
<td> 细部的系统设计时间                               </td>
</tr>
<tr>
<td> 相关文件      </td>
<td> 收录在系统设计规格书(SDS)                   </td>
<td> 同左                                            </td>
</tr>
<tr>
<td> 实作情况      </td>
<td> 无法直接对应程序代码                        </td>
<td> 可以直接对应程序代码(有些UML工具可以自动产码)     </td>
</tr>
<tr>
<td> 绘制者         </td>
<td> 系统设计师                                   </td>
<td> 同左                                            </td>
</tr>
<tr>
<td> 观看者         </td>
<td> 程序设计师                                   </td>
<td> 同左                                            </td>
</tr>
<tr>
<td> 粒度            </td>
<td> 一张活动图对应一个用例(即将用例视为白箱)   </td>
<td> 同左                                            </td>
</tr>
</tbody>
</table>


<p>活动图图标:</p>

<ol>
<li>起始节点: 实心小圆 (建议一个活动图 一个起始节点)</li>
<li>活动终点: 双圆,内实外空</li>
<li>判断节点: 空心菱形</li>
<li><p>动作: 圆角矩形 动作粒度要与用例粒度相近</p>

<p> 4.1 第一行: (一个动作负责人)</p>

<p> 4.2 第二行: 动作名称,动词开头</p></li>
<li>合并节点: 空心菱形</li>
<li>活动: 圆角矩形,右下角三叉图标 (活动可拆分外令一个活动图 )</li>
<li>分叉与会合: 粗线段 (等所有条件具备进行下一阶段 建议分叉与会合成对出现)</li>
<li>对象节点: 矩形 (代表流入/流出的数据项)</li>
</ol>


<h3>3. 用例建模</h3>

<p>用例来源:</p>

<ol>
<li>业务流程</li>
<li>功能流程</li>
<li>其他用例</li>
</ol>


<p>建议同时生成用例图和功能架构图.</p>

<p>用例图作用:</p>

<ol>
<li>规范一套动作</li>
<li>明确结果</li>
<li>表明参与者 (参与者包括主要参与者(启动者)和次要参与者)</li>
</ol>


<p>业务流程导出初版用例</p>

<ol>
<li>查看动作,动作负责人即为参与者,动作即为用例</li>
<li>查看判断节点,判断判断节点是否需要其他用例支持</li>
</ol>


<p>功能划分->业务流程->初版用例->功能架构->用例图->用例描述</p>

<p>用例描述:</p>

<ol>
<li>前置条件: 执行流程前必须要满足的条件</li>
<li>主要流程: 一般正常的流程 (主要详细分为参与者输入,系统处理过程,及输出,要求非常详细!)</li>
<li>替换流程: 特殊情况 (替换流程的编号,紧跟发生特殊情况的主要流程编号)</li>
<li>后置条件: 必须要完成的结果</li>
</ol>


<p>包含关系与扩展关系</p>

<ol>
<li><p>包含关系: <code>&lt;&lt;include&gt;&gt;</code> 虚线箭头指向被包含 被包含可视为<code>前置条件</code></p>

<p> 1.1 被包含的小用例无法脱离基础用例而单独存在</p>

<p> 1.2 基础用例一定执行被包含的小用例</p>

<p> 1.3 两者加起来是一条流程</p></li>
<li><p>扩展关系: <code>&lt;&lt;extends&gt;&gt;</code> 虚线箭头直线被扩展 扩展可不执行 ,可视为<code>替换流程</code></p>

<p> 2.1 拓展的小用例无法脱离基础用例而单独存在</p>

<p> 2.2 基础用例不一定执行拓展的小用例</p>

<p> 2.3 两者加起来是两条流程,其一是单独的基础用例,其二是基础用例外加拓展用例</p></li>
</ol>


<h3>4. 领域建模</h3>

<p>领域模型:</p>

<ol>
<li>一种概念模型,呈现问题领域中的重要概念</li>
<li>描述问题领域中的实体,实体属性,操作,角色,关系和限制.</li>
<li>对于用例所描述的互动过程,领域模型可以为用例起支持结构作用.</li>
<li>通常用类图描述领域模型.</li>
<li>领域模式可用于出代码</li>
</ol>


<p>类图:</p>

<ol>
<li>类用矩形表示,第一行为名称,第二行为属性,第三行为操作</li>
<li>属性 属性名称:数据类型=初始值</li>
<li>操作 操作名称(参数,数据类型):返回值数据类型</li>
<li><p>结合关系: 实线 表示两个领域存在重要且需要永久保存的静态关系</p>

<p> 4.1 单向结合 无法从目标端找回来源端</p>

<p> 4.2 双向结合</p>

<p> 4.3 聚合关系 空心菱形 指向聚合类 整体-部分</p>

<p> 4.4 组合关系 实心菱形 组合关系具有聚合关系的所有特性另加部分对象只会链接到一个整体对象,不允许数个整体对象共用一个部分对象,部分对象跟随整体对象的存活.</p>

<p> 4.3 个体数目 下限..上限 表明关系:一对一,一对多,多对多.多对一.</p></li>
</ol>


<p>用例描述推导领域模型</p>

<ol>
<li>查看用例描述,把其中的数据项归到领域中.</li>
<li>类代表领域,数据项代表属性</li>
<li>查看概念之间的关系</li>
<li>根据关系在两端添加数量</li>
</ol>


<p>领域模型呈现业务规则</p>

<ol>
<li>通过结合关系和个体数目来表达关系静态结构的业务规则</li>
<li>通过操作来表达计算公司以及一些需要查验或检核的业务规则</li>
</ol>


<h3>5. 模型走读</h3>

<p>作用:检测模型质量</p>

<p>走读功能架构图与用例图</p>

<ol>
<li>是否可以从功能架构图追溯到用例图 (最好情况: 直接采用用例作为功能架构图中的功能)</li>
<li>检测功能架构图中的系统,功能模块,用例名称是否和用例图一致</li>
<li>若功能模块和底下的功能模块与客户的征求建议书(RFP)不一致,则需请求客户同意,看功能模块的切割、名称、地下的功能归属是否恰当.</li>
</ol>


<p>走读中遇到的问题及其解决方案:</p>

<ol>
<li>出现多个用例参与一个用例入口 解决:用例图中参与者第二行标明{or }</li>
</ol>


<p>走读用例图和用例描述</p>

<ol>
<li>检测参与者是否摆在系统方框之外,在系统方框和功能模块方框最上方要用标注&lt;\&lt;系统>>或&lt;\&lt;功能模块>></li>
<li>用例描述每一个步骤都以参与者或系统开头</li>
</ol>


<p>界面雏形工具: Pencil</p>

<p>走读用例描述与领域模型</p>

<ol>
<li>主要查看是否遗漏数据项(属性)、业务规则和重要操作</li>
</ol>


<h5>善用对象图</h5>

<p>对象图是系统的快照,可表示某一时刻或某一场景系统内有哪些重要对象,属性的数值以及他们之间的关系.</p>

<p>在绘制对象图,想好场景,一边套场景,一边通过对象图走读领域模型</p>

<p>用对象图发现用例描述某一动作不能执行, 解决方案 增加用例辅助完成.</p>

<h4>领域模式描述:</h4>

<p>领域模式主要通过文字记录类别、属性、结合、限制的定义或解释、操作</p>

<h3>6. 继续走读</h3>

<p>走读中做了几个调整.</p>

<p>1.整合应整合用例(自动汇整集锦交易与自动申购基金)</p>

<p>非功能性需求可以添加到用例描述中或建立单独一个表格供整个系统参考.</p>

<p>走读领域,可搭配情景对象图.这个很重要,其实在做系统测试时候,完全可以按照这个来.</p>

<h3>7. 基金系统范例</h3>

<p>以功能模块拆分用例图.</p>

<p>主要把前面章节的图 汇总在一起.</p>

<h3>总结</h3>

<p>第四章的结合实例来说领域模型很精彩</p>

<p>重复地方很多,有利有弊.</p>

<p>对于整个系统流程来说,算是不错的体验.能够让读者大概明白UML的大概过程,每一步应该做什么.然后循环迭代.这和敏捷开发的思想很像.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PHP工具]]></title>
    <link href="http://mzkmzk.github.io/blog/2015/09/30/php_utils/"/>
    <updated>2015-09-30T11:37:40+08:00</updated>
    <id>http://mzkmzk.github.io/blog/2015/09/30/php_utils</id>
    <content type="html"><![CDATA[<!--more-->


<h3>IDE</h3>

<p>PHPStore</p>

<p>官网下载</p>

<p>破解码<code>EMBRACE</code></p>

<p>参考<a href="http://orgcent.com/phpstorm-register-key-license/">http://orgcent.com/phpstorm-register-key-license/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Laravel 错误积累]]></title>
    <link href="http://mzkmzk.github.io/blog/2015/09/30/Laravel_error/"/>
    <updated>2015-09-30T11:37:40+08:00</updated>
    <id>http://mzkmzk.github.io/blog/2015/09/30/Laravel_error</id>
    <content type="html"><![CDATA[<!--more-->


<h4>[Laravel5] TokenMismatchException in VerifyCsrfToken</h4>

<p>form表单内添加</p>

<pre><code>&lt;input type="hidden" name="_token" value=""&gt;
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Laraval 入门]]></title>
    <link href="http://mzkmzk.github.io/blog/2015/09/24/Laravel-start/"/>
    <updated>2015-09-24T11:37:40+08:00</updated>
    <id>http://mzkmzk.github.io/blog/2015/09/24/Laravel-start</id>
    <content type="html"><![CDATA[<!--more-->


<h2>配置与安装</h2>

<p>需要条件:</p>

<pre><code>- PHP &gt;= 5.5.9 - OpenSSL PHP 扩展 - PDO PHP 扩展 - Mbstring PHP 扩展 - Tokenizer PHP 扩展
</code></pre>

<p>查看方式:<code>phpinfo();</code></p>

<p>配置composer.</p>

<p>配置<code>~/.composer/vendor/bin</code>到PATH</p>

<p>安装Laravel</p>

<pre><code>sudo composer global require "laravel/installer=~1.1"
</code></pre>

<p>之后就<code>laravel new blog</code> 爽一爽</p>

<p>/config里都是配置文件 需要仔细看看.</p>

<p>配置/storage和bootstrap/cache服务器写权限</p>

<pre><code> chmod -R  777   storage/
 chmod -R  777   bootstrap/cache
</code></pre>

<p>ok,把项目放进apache路径 然后</p>

<pre><code>http://localhost/laravel/public/
</code></pre>

<p>就会看到Laravel 5字样了</p>

<p>我们自己试一试弄一个页面吧</p>

<p>打开<code>/app/Http/routes.php</code>,设置Url跳转和传递title参数</p>

<pre><code>Route::get('/hi',function(){
return View::make('hi')-&gt;with("title","Hello Word");
});
</code></pre>

<p>打开<code>/resources/views</code>创建hi.blade.php</p>

<pre><code>@include('header')
&lt;h1&gt;&lt;/h1&gt;
&lt;p&gt;one Laravel&lt;/p&gt;
</code></pre>

<p>再在其目录下创建header.blade.php</p>

<pre><code>&lt;p&gt;header&lt;/p&gt;
</code></pre>

<p>ok 访问url<code>http://localhost/laravel/public/index.php/hi</code></p>

<p>如何去掉可恶的index.php</p>

<ol>
<li>设置apache支持.htaccess,打开apache http.conf,搜索<code>AllowOverride</code> 把None都改为All</li>
<li>设置加载mod_rewrite模块,打开apache http.conf,搜索<code>mod_rewrite</code>,把前面的#去掉(校验方法-php_info()),重启下apache哦~.</li>
<li><p>设置Laravel的.htaccess,把下面的内容代替之前的内容.</p>

<pre><code> Options +FollowSymLinks
 RewriteEngine On

 RewriteCond %{REQUEST_FILENAME} !-d
 RewriteCond %{REQUEST_FILENAME} !-f
 RewriteRule ^ index.php [L]
</code></pre></li>
</ol>


<p>ok<code>http://localhost/laravel/public/hi</code>爽一发吧.</p>

<p>参考链接<a href="http://oublog.cn/u_58/">http://oublog.cn/u_58/</a></p>

<p>环境配置</p>

<pre><code>//获取系统配置
config('app.timezone')
//设置系统配置
config(['app.timezone' =&gt; 'Asia/Shanghai'])
</code></pre>

<h3>路由</h3>

<p>访问Controllers</p>

<pre><code>Route::get('/Text_Laravel/Text_DB','Text_Laravel.Text_DB@index');
</code></pre>

<p>访问View</p>

<pre><code>Route::get('/User/Login',function () {
return view('User.Login');
});
</code></pre>

<h3>数据库配制</h3>

<p>配置文件<code>config/database.php</code></p>

<p>Laravel还可以配置读写两个不同的ip地址.</p>

<pre><code>'mysql' =&gt; [
'read' =&gt; [
    'host' =&gt; '192.168.1.1',
],
'write' =&gt; [
    'host' =&gt; '196.168.1.2'
],
'driver'    =&gt; 'mysql',
'database'  =&gt; 'database',
'username'  =&gt; 'root',
'password'  =&gt; '',
'charset'   =&gt; 'utf8',
'collation' =&gt; 'utf8_unicode_ci',
'prefix'    =&gt; '',
],
</code></pre>

<p>光配置这个还不行 还要去配置.env ? 难道.env是通过config实时生成的?</p>

<h2>阅读API文档</h2>

<p><a href="http://www.golaravel.com/laravel/docs/5.1/">http://www.golaravel.com/laravel/docs/5.1/</a></p>

<h3>routing</h3>

<p><a href="http://laravel.com/docs/5.1/routing">http://laravel.com/docs/5.1/routing</a></p>

<p>路由配置在<code>app/Http/routes.php</code></p>

<p>先来看下简单的配置,get,post请求,还有match,any匹配多种请求,还有通过url传递参数(参数不能包含<code>-</code>),</p>

<h2>应用中碰到的应用</h2>

<h3>获取路径</h3>

<p>获取相对于目录的绝对路径</p>

<p>详见<a href="http://www.golaravel.com/laravel/docs/5.1/helpers/#paths">http://www.golaravel.com/laravel/docs/5.1/helpers/#paths</a></p>

<ol>
<li><p>获取网络路径</p></li>
<li><p>关闭CSRF,<code>App\Http;\Kernel</code>,注释</p>

<pre><code>  // \App\Http\Middleware\VerifyCsrfToken::class,
</code></pre></li>
</ol>


<h3>快速查找SQL语句</h3>

<pre><code>Route::get('/test-sql', function() {

DB::enableQueryLog();
$text = App\Models\Sample_Model::find(647)
    -&gt;patient()
    -&gt;Paginate(15)
    -&gt;toJson();

return response()-&gt;json(DB::getQueryLog());
});
</code></pre>

<p>eg:   <br/>
参考<a href="http://laravel.so/tricks/3c8bda45c15f494eaeba1690556aa40a">http://laravel.so/tricks/3c8bda45c15f494eaeba1690556aa40a</a></p>

<h3>记录SQL到 日志</h3>

<p><a href="http://laravel.so/tricks/6086494cbfde9950e9118b1dad6270d5">http://laravel.so/tricks/6086494cbfde9950e9118b1dad6270d5</a></p>

<h3>Laravel级联查询</h3>

<p>会调用patient()方法</p>

<pre><code>Sample_Model::with('patient');
</code></pre>

<p>with属于懒加载..一般是最后需要用到的时候才执行</p>

<h3>with记载上层数据时,不会显示被删除的数据</h3>

<p>更改前</p>

<pre><code>class Patient_Controller extends Controller{

public function query(Request $request){

$result = Patient_Model::withTrashed();
    -&gt;orderBy("updated_at","desc")
    -&gt;Paginate(15)
    -&gt;toJson();

   return $result;
}
//更改前执行的sql
select count(*) as aggregate from `samples`
select * from `samples` order by `updated_at` desc limit 1 offset 0
select * from `patients` where  `patients`.`deleted_at` is null and `patients`.`code` in ('P-SZ150917134BrC')
</code></pre>

<p>更改后</p>

<pre><code>public function query(Request $request){

  $result = Sample_Model::with(['patient' =&gt; function($q) {
    $q-&gt;withTrashed();
}])
-&gt;withTrashed()
-&gt;orderBy("updated_at","desc")
-&gt;Paginate(1)
-&gt;toJson();

return $result;
}

//更改后执行的sql是
select count(*) as aggregate from `samples`
select * from `samples` order by `updated_at` desc limit 1 offset 0
select * from `patients` where `patients`.`code` in ('P-SZ150917134BrC')
</code></pre>

<p>ok with 函数究竟是神马鬼?来看下源代码</p>

<pre><code>  /**
 * Begin querying a model with eager loading.
 *
 * @param  array|string  $relations
 * @return \Illuminate\Database\Eloquent\Builder|static
 */
public static function with($relations)
{
    if (is_string($relations)) {
        $relations = func_get_args();
    }

    $instance = new static;

    return $instance-&gt;newQuery()-&gt;with($relations);
}   
</code></pre>

<p>首先他是懒加载,需要用的时候才加载,$relations可以是string也可以是数组,string的话就直接调用model的函数,数组的话,就是后面可以加判定条件.   <br/>
参考链接<a href="http://stackoverflow.com/questions/33006470/laravel-query-delete-relationships">http://stackoverflow.com/questions/33006470/laravel-query-delete-relationships</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[js 坑点]]></title>
    <link href="http://mzkmzk.github.io/blog/2015/09/21/js_error/"/>
    <updated>2015-09-21T11:37:40+08:00</updated>
    <id>http://mzkmzk.github.io/blog/2015/09/21/js_error</id>
    <content type="html"><![CDATA[<h1>未解决</h1>

<p>莫名其妙.在div中设置onclick方法就能找该方法,在包含下的input下就找不到.</p>

<pre><code>'&lt;div class="col-sm-1" onclick="delete_library()"&gt;'+
        '&lt;input  onclick="delete_library()" class="btn btn-info" id="delete_library_'+new_library_num+'" name="delete_library" value="删除"   style="width:100%"  /&gt;'+    
    '&lt;/div&gt;';
</code></pre>

<h1>已解决</h1>

<ol>
<li>jquery的ajax中不能再方法内return,返回的都是undefinte;</li>
<li>js加减乘除中运用在浮点数会不准确,需要另写方法,参考<a href="http://segmentfault.com/a/1190000000324193">http://segmentfault.com/a/1190000000324193</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[开发规范]]></title>
    <link href="http://mzkmzk.github.io/blog/2015/09/21/develop_norm/"/>
    <updated>2015-09-21T11:37:40+08:00</updated>
    <id>http://mzkmzk.github.io/blog/2015/09/21/develop_norm</id>
    <content type="html"><![CDATA[<h3>ALL</h3>

<p>文件和文件夹用<em>,方法和变量用驼峰
在函数名和变量名种一个</em>分割功能,描述一个功能的两个单词用驼峰</p>

<p>包名 首字母大写</p>

<h3>JS</h3>

<h3>CSS</h3>

<h3>HTML</h3>

<ol>
<li>在控件中,id绝对不能重复,要重复.宁可不设</li>
</ol>


<h3>Adnroid</h3>

<h3>php</h3>

<h3>iOS</h3>

<h3>ERROR</h3>

<ol>
<li>类 方法 错误 参数;</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[phpUnit 入门]]></title>
    <link href="http://mzkmzk.github.io/blog/2015/09/16/phpUnit_start/"/>
    <updated>2015-09-16T11:37:40+08:00</updated>
    <id>http://mzkmzk.github.io/blog/2015/09/16/phpUnit_start</id>
    <content type="html"><![CDATA[<h3>参考链接</h3>

<p>高大上的API<a href="https://phpunit.de/manual/current/zh_cn/">https://phpunit.de/manual/current/zh_cn/</a></p>
]]></content>
  </entry>
  
</feed>
