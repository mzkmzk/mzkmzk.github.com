<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: javascript | K]]></title>
  <link href="http://mzkmzk.github.io/blog/categories/javascript/atom.xml" rel="self"/>
  <link href="http://mzkmzk.github.io/"/>
  <updated>2015-10-07T19:57:27+08:00</updated>
  <id>http://mzkmzk.github.io/</id>
  <author>
    <name><![CDATA[K]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[疯狂Html+CSS+JS 中JS总结]]></title>
    <link href="http://mzkmzk.github.io/blog/2015/10/05/amazeing-js/"/>
    <updated>2015-10-05T11:37:40+08:00</updated>
    <id>http://mzkmzk.github.io/blog/2015/10/05/amazeing-js</id>
    <content type="html"><![CDATA[<!--more-->


<h2>1. JavaScript语法</h2>

<h3>1.1执行js代码</h3>

<ol>
<li>javascript:alert(&lsquo;执行js&rsquo;);</li>
<li><code>&lt;script&gt;alert("执行js")&lt;/script&gt;</code></li>
</ol>


<h3>1.2变量赋值</h3>

<pre><code>var a = 1;//显式
a =1; //隐式
</code></pre>

<h3>1.3全局变量与局部变量</h3>

<pre><code>...
var scope = "全局变量";
function test(){
    alert(scope);
    var scope = "局部变量";
    alert(scope);
}
</code></pre>

<p>结果是先alert undefined 后 alert 局部变量</p>

<p>因为全局变量被局部变量覆盖了.虽然局部变量的scope还没赋值,但是已经在方法里&#8221;占&#8221;上位置了.</p>

<p>但如果把局部变量的var删了,就会先输出全局变量后输出局部变量,因为没有var在方法里给局部变量&#8221;占&#8221;位置;</p>

<h3>1.4浮点数</h3>

<pre><code>var a =.333
var b = a * 5;
alert(b);
</code></pre>

<p>得出的结果是 1.66499999999999999</p>

<p>所以在js中判断浮点数是否相等 建议判断两者的差值是否小于一个足够的数(例如0.0000000000001)</p>

<h3>1.5字符串</h3>

<p>js中没有字符类型变量 &ldquo;&#8221;与&#8217;&lsquo;一致</p>

<pre><code>var s ="abcdefg"

//b = "def"
b = s.slice(3, -1);
</code></pre>

<h3>1.6字符串的正则表达式方法中</h3>

<ol>
<li>match()返回匹配的字符串(数组或null),可加/g进行全局匹配多个</li>
<li>search()返回匹配的索引值 单个</li>
</ol>


<h3>1.7undefined 和null</h3>

<pre><code>null == undefined //true

null === undefined //false
</code></pre>

<p>undefined 是没设值</p>

<p>null则是设定了为null值</p>

<h3>1.8运算符</h3>

<pre><code>//逗号运算符 取最右返回值
a = (b =5 , c = 7 , d =56) //a =56

a = void(b =5 , c = 7 , d =56) //a = undefined
</code></pre>

<h3>1.9typeof 和 instanceof</h3>

<p>typeof 用来获得 实例类型 :</p>

<pre><code>typeof("123"); //string
</code></pre>

<p>instanceof 判断变量是否为某类的实例</p>

<pre><code>var a = [4,5];
alert(a instanceof Array); //true
</code></pre>

<h3>1.10语句</h3>

<p>抛出异常</p>

<pre><code>throw new Error("用户自定义异常"); //一般用于终止程序和返回错误提示是个不错的选择;

try{

}catch(e){
    alert(e.message); // "用户自定义异常"
}
</code></pre>

<p>for in</p>

<pre><code>//这回输出浏览器的所有属性,做浏览器兼容之前可以考虑看看.
for( prop_name in navigator){
    document.wrti(prop_name + " : " + navigator[propname]);
}   
</code></pre>

<p>跳出命名for</p>

<pre><code>outer: 
for(...){
    for(...){
        ...
        continue outer;
    }
}
</code></pre>

<h3>1.11函数</h3>

<p>js 允许先调用函数 再定义函数</p>

<h4>1.11.1定义匿名函数</h4>

<pre><code>var show_name = function(name){
    alert(name);
}

show_name("K"); //K
</code></pre>

<p>这样的好处是什么,如果直接定义function 它实际上也是创建了一个对象</p>

<h4>1.11.2函数既对象</h4>

<pre><code>var hello = function(){...};

hello instanceof Function //true;

hello instanceof Object //true;

alert(heelo) //输出函数源代码
</code></pre>

<h4>1.11.3调用函数方式的不同</h4>

<ol>
<li>直接调用函数 返回return的值或void</li>
<li>new 函数 得到的都是对象 - -&hellip;&hellip;.</li>
</ol>


<h4>1.11.4this关键字.</h4>

<p>在函数中使用this.变量 该变量就是函数的实例变量,而非局部变量,无论它在哪里.</p>

<p>函数可依附在类中.如没指定 则依附在winodw对象中</p>

<pre><code>var hello =function(){...}

window.hello();

var p = {
    wark: function(){...}
}
p.wark();
</code></pre>

<h4>1.11.5函数中的变量有三种</h4>

<pre><code>function Person(){
    //局部变量 只能在函数里访问
    var id ;

    //实例属性 通过对象.访问
    this.age ;

    //类属性 通过Patient.name访问 与static类似
    Person.name ;
}
</code></pre>

<h4>1.11.6js是一种动态语言,能随时给对象增加属性和方法</h4>

<pre><code>function Student(){ };

var student =new Student();
//动态增加name属性
student.name = 'K';
alert(sutdent.name) //K

Student.age =22 ;
alert(Student.age); //22 类属性也是可以动态添加的
</code></pre>

<h4>1.11.7调用函数的三种方式</h4>

<ol>
<li><p>直接调用</p>

<pre><code> windows.alert();
 //or
 alert();
</code></pre></li>
<li><p>call()调用</p>

<p> 作用:动态地传入一个函数引用</p>

<pre><code> var each = function(array,fn){
     for(var index in arrary){
         //null表示以window为调用者fn函数
         fn.call(null,index,arrary[index]);
     }
 }

 each([4,20,3] , function(index ,ele){
     alert("第 " + index "个元素是 : " + ele);
 });
</code></pre>

<p> call()调用函数语法为:<code>函数引用.call(调用者,参数1,参数2...)</code></p>

<p> 直接调用函数语法为:<code>调用者.函数(参数1,参数2 ...)</code> = <code>函数.call(调用者,参数1,参数2 ...)</code></p></li>
<li><p>apply()调用</p>

<p> apply和()call()基本相似,区别如下:</p>

<ol>
<li>通过call()调用函数时,括号必须详细列出每个参数</li>
<li><p>通过apply()动态地调用函数时,可以在括号中以<code>arguments</code>来代表所有参数</p>

<pre><code> var myfun = function (a , b){
     alert(a + "  " +b);
 }

 myfun.call(window ,12 ,23); //12 23;

 myfun.apply(window ,[20 , 39]); //20 39

 var example = function (num1 ,num2){
     //直接调用arguments代表调用者(example,this代表example)时的传入的所有参数
     myfun.apply(this,arguments); 
 }
 example(20,40) //20 40 
</code></pre></li>
</ol>
</li>
</ol>


<h4>1.11.8函数的独立性</h4>

<p>在函数A中可以定义函数B,但是函数B还是独立于函数A</p>

<pre><code>function Person(name){
    this.name = name;

    this.info = function(){
        alert(this.name);
    }
}   

var person =new Person('K');
person.info(); //K
var name = 'K_window';

//由于window为调用者 ,this.name访问的是window.name
p.info.call(window); //K_window
</code></pre>

<p>来爽一发猫学狗叫?.</p>

<pre><code>function Dog(name,bark){
    this.name = name;
    this.bark = bark;
    this.info =function(){
        alert(this.name + "  " + this.bark);
    }
}

function Cat(name){
    this.name =name;
}   

var dog = new Dog("K","汪汪!");
var cat = new Cat("K_2");
dog.info.call(cat); //K_2 undefined
</code></pre>

<h4>1.11.9参数传递方式</h4>

<p>和JAVA一样 都是值传递拉~.</p>

<p>基本类型</p>

<pre><code>function change(arg){
    arg =10 ;
    alert(arg);
}
var x = 5;
alert(x); //5
change(x); //10
alert(x); //5
</code></pre>

<p>复合类型</p>

<pre><code>function change(person){
    person.age = 10;
    alert(person.age);
    person = null;
}

var person = {age : 5};
alert(person.age); //5
change(person); //10
alert(person.age); // 10
alert(person); // []object Object]
</code></pre>

<p>复合类型的传递为值传递,原person和参数person指向同一javascript对象,所以当改变age的时候,是在改变javascript对象的age,但是参数person赋值为null,原person并无改变.</p>

<h4>1.11.10空参数</h4>

<pre><code>function text(person){
    alert( typeof parson);
}

text(); //undefined
</code></pre>

<p>所以对于弱类型,方法重载是无作用的,因为js会把空参数当做undefined传递进去;</p>

<p>同名函数,后面出现的会覆盖前面的,无论参数个数是多少.</p>

<h4>1.11.11对象和关联数组</h4>

<p>javascript和Map有点类似,当key为对象,value为函数,该该函数就是对象的方法,当key为对象,value为基本类型,则该基本类型为对象的属性.(以上为便于理解,切勿细琢)所以访问属性时,可以obj.propName也可以obj[propName].</p>

<p>但有时候我们只能用obj[propName],因为.propName不能把propName当做变量处理,而是把他当成&#8217;propName&#8217;字符串</p>

<pre><code>function Person(name){
    this.name =name;
    this.info = function(){
        alert(K);
    }
}

var person = new Person("K");
//遍历person属性
for (propName in person){
    alert(p[propName]);//alet K info源代码 假如此处用p.propName则undefined,因为Person无'propName'变量.
}
</code></pre>

<h4>1.11.12继承和prototype</h4>

<p>在一个类(函数)中定义一个函数会导致</p>

<ol>
<li>性能低下:每次new一个类 都会生成一个函数</li>
<li><p>函数中若引用类的局部变量会产生闭包 导致局部变量一直存在</p>

<pre><code> function Person(){
     var local = "局部变量"
     this.info = function(){
         //产生闭包
         alert(local);
     }
 }

 var person = new Person();
 person.ifno(); // 局部变量  
</code></pre></li>
</ol>


<p>解决方案:prototype</p>

<p>增加了prototype属性的类可视为继承了原先的类(伪继承)</p>

<pre><code>function Person(){...}

var person = new Person();

//person.wark(); 程序报错wark不存在
Person.prototype.wark = function(){...}

person.wark(); //ok
</code></pre>

<p>在prototype之前实例化的类会具有wark方法吗? 有的,因为prototype这样并不会产生一个新的类,而是直接动态的往Person里加函数.</p>

<h3>1.12创建对象三种方式</h3>

<pre><code>//(单身汪别说我不教你)
</code></pre>

<ol>
<li><p>new关键字调用构造器创建对象</p>

<pre><code> function Person(name){...}
 var person_1 = new Person();
 var person_2 = new Person('K'); //js不存在方法重载,空参数undefined顶替
</code></pre></li>
<li><p>使用Oject直接创建对象</p>

<pre><code> var my_obj = new Object();
 my_ojb.name = 'K';
 my_obj.handsome = function(){...}

 function text(){...}
 my_obj.text = text;//不要添加(),不然会认为是调用方法
</code></pre></li>
<li><p>JSON创建对象</p>

<pre><code> ver person = {
     name : 'K',
     school : ['ChangAn','TianJin'],
     girl_friends :[
         {
             name : 'Haski',
             age : 11
         },
         {
             name : 'Samoyed',
             age : '8'
         }
     ]
 }
</code></pre></li>
</ol>


<h3>DOM编程</h3>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[js 坑点]]></title>
    <link href="http://mzkmzk.github.io/blog/2015/09/21/js_error/"/>
    <updated>2015-09-21T11:37:40+08:00</updated>
    <id>http://mzkmzk.github.io/blog/2015/09/21/js_error</id>
    <content type="html"><![CDATA[<h1>未解决</h1>

<p>莫名其妙.在div中设置onclick方法就能找该方法,在包含下的input下就找不到.</p>

<pre><code>'&lt;div class="col-sm-1" onclick="delete_library()"&gt;'+
        '&lt;input  onclick="delete_library()" class="btn btn-info" id="delete_library_'+new_library_num+'" name="delete_library" value="删除"   style="width:100%"  /&gt;'+    
    '&lt;/div&gt;';
</code></pre>

<h1>已解决</h1>

<ol>
<li>jquery的ajax中不能再方法内return,返回的都是undefinte;</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用jQuery MiniUI搭建后台demo]]></title>
    <link href="http://mzkmzk.github.io/blog/2015/03/28/jquery_miniui/"/>
    <updated>2015-03-28T11:37:40+08:00</updated>
    <id>http://mzkmzk.github.io/blog/2015/03/28/jquery_miniui</id>
    <content type="html"><![CDATA[<p>jQuery MiniUI 提供了一套.net/php/java 的后台模板 这里介绍一下使用方法</p>

<h3>0x00下载demo</h3>

<p><a href="http://www.miniui.com/download/">http://www.miniui.com/download/</a></p>

<p>在这里选择使用的语言</p>

<h3>0x01导入demo</h3>

<h4>java</h4>

<p>在Eclipse导入<code>import-&gt;Existing Project</code>以后</p>

<p>项目会出现小红叉</p>

<p>解决办法:</p>

<p>删除不存在的jre
<code>右击项目-&gt;Bulid path-&gt;选中Libraries标签页-&gt;选中有小红叉的JRE -&gt;remove</code></p>

<p>导入本地的jre
<code>Add Library-&gt;Jre System Library-&gt;OK</code></p>

<p>如果此时项目中WebContent文件中有jsp报错 则Close项目 然后再Open</p>

<p>修改src中的TestDB.java中的相关数据库信息</p>

<h4>php</h4>

<p>把项目扔进apache的目录即可</p>

<p>然后在demo/data/invoke.php，修改相关数据库配置字符串。</p>

<h4>导入mysql数据库</h4>

<p>下载的项目中的WebContet中有个dbsql</p>

<p>如果导入.sql文件不存在..说数据库已存在 则</p>

<p>打开.sql文件 注释创建数据库的代码行</p>

<pre><code>#CREATE DATABASE `plusoft_test`
#CHARACTER SET 'utf8'
#COLLATE 'utf8_general_ci';

#USE `plusoft_test`;    
</code></pre>

<p>ok 运行项目即可</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[js 函数累积]]></title>
    <link href="http://mzkmzk.github.io/blog/2015/01/07/js_function/"/>
    <updated>2015-01-07T11:37:40+08:00</updated>
    <id>http://mzkmzk.github.io/blog/2015/01/07/js_function</id>
    <content type="html"><![CDATA[<p>jquery api<a href="http://jquery.bootcss.com/">http://jquery.bootcss.com/</a></p>

<h3>select 选中项</h3>

<pre><code>设置select中value="paraValue"的Item为选中    
document.all.objSelect.value = objItemValue;  
</code></pre>

<p>参考链接<a href="http://www.cnblogs.com/Herist/archive/2007/09/24/903890.html">http://www.cnblogs.com/Herist/archive/2007/09/24/903890.html</a></p>

<h3>Dom元素加载完毕后调用方法 ready()</h3>

<pre><code>$(document).ready(function(){
    $(".btn1").click(function(){
        $("p").slideToggle();
    });
});
</code></pre>

<p>参考链接<a href="http://www.w3school.com.cn/jquery/event_ready.asp">http://www.w3school.com.cn/jquery/event_ready.asp</a></p>

<h3>jquery 控制css</h3>

<p>通过控制class为button_left的鼠标移入动作把id为up_page设置为可见</p>

<pre><code>$(".button_left").mouseover(function(){
$("#up_page").css("visibility","visible");
});
</code></pre>

<h3>js动态添加 from表单元素</h3>

<pre><code>//from_this参数作用为Onsubmit事件传递过来的from表单 或者通过id获取也可以
function  inser_Submit(from_this){
     var NFC_ID=document.createElement("input");
     NFC_ID.type="hidden";
     NFC_ID.name="NFC_ID";
     NFC_ID.value=document.getElementById("NFCID").value;
     from_this.appendChild(NFC_ID);
}   
</code></pre>

<h3>js设置cookie</h3>

<pre><code>document.cookie="key=value; path=/"
</code></pre>

<h3>form表单动态添加子成员</h3>

<pre><code>var page_form =document.createElement("form");
page_form.appendChild(document.getElementById("search_type"));
page_form.appendChild(document.getElementById("search_cancer_type"));
page_form.appendChild(document.getElementById("search_info"));
</code></pre>

<h3>函数积累</h3>

<ol>
<li>.trim();</li>
<li>window.location.href获取当前url</li>
<li>parseInt(String) Stirng转int</li>
<li>string.split(&lsquo;string_split&rsquo;) 方法用于把一个字符串分割成字符串数组。</li>
</ol>


<h3>jqeury函数积累</h3>

<ol>
<li>addClass(&ldquo;class&rdquo;); removeClass(&ldquo;class&rdquo;); 切换class:toggleClass(&ldquo;class&rdquo;);</li>
<li>获取内容.html(); 设置内容.html(&ldquo;内容&rdquo;);</li>
<li>$(document).ready(function(){});document加载完后执行的函数</li>
</ol>


<h3>注意点</h3>

<ol>
<li>用js提交form表单时,最好用get方法,因为用post方法的话,返回上一页需要重新提交表单.</li>
<li>jQuery的show()和hide()函数时,注意如果该空间不需要提交到form内,要<code>$("#id").attr("disabled",true);</code></li>
</ol>


<h3>js验证身份证</h3>

<pre><code>function IdentityCodeValid(code) {
    var city = {
        11: "北京",
        12: "天津",
        13: "河北",
        14: "山西",
        15: "内蒙古",
        21: "辽宁",
        22: "吉林",
        23: "黑龙江 ",
        31: "上海",
        32: "江苏",
        33: "浙江",
        34: "安徽",
        35: "福建",
        36: "江西",
        37: "山东",
        41: "河南",
        42: "湖北 ",
        43: "湖南",
        44: "广东",
        45: "广西",
        46: "海南",
        50: "重庆",
        51: "四川",
        52: "贵州",
        53: "云南",
        54: "西藏 ",
        61: "陕西",
        62: "甘肃",
        63: "青海",
        64: "宁夏",
        65: "新疆",
        71: "台湾",
        81: "香港",
        82: "澳门",
        91: "国外 "
    };
    var tip = "";
    var pass = true;

    if (!city[code.substr(0, 2)]) {
        tip = "身份证地址编码错误";
        pass = false;
    } else {
        //18位身份证需要验证最后一位校验位
        if (code.length == 18) {
            code = code.split('');
            //∑(ai×Wi)(mod 11)
            //加权因子
            var factor = [7, 9, 10, 5, 8, 4, 2, 1, 6, 3, 7, 9, 10, 5, 8, 4, 2];
            //校验位
            var parity = [1, 0, 'X', 9, 8, 7, 6, 5, 4, 3, 2];
            var sum = 0;
            var ai = 0;
            var wi = 0;
            for (var i = 0; i &lt; 17; i++) {
                ai = code[i];
                wi = factor[i];
                sum += ai * wi;
            }
            var last = parity[sum % 11];
            if (parity[sum % 11] != code[17]) {
                tip = "身份证校验位错误";
                pass = false;
            }
        }
    }
    if (!pass) alert(tip);
    return pass;
}
</code></pre>

<h3>操作json</h3>

<ol>
<li>向一个元素添加属性<code>json[i].key=value</code>;</li>
<li>json转为String<code>JSON.stringify()</code>参考链接<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify</a></li>
<li><p>json新增元素</p>

<pre><code> var title_x = [];
 var key = { "key" : value };
 title_x.push(key);
</code></pre></li>
<li><p>json排序<a href="http://www.cnblogs.com/breakdown/archive/2012/08/03/2619480.html">http://www.cnblogs.com/breakdown/archive/2012/08/03/2619480.html</a></p></li>
</ol>


<p>参考链接<a href="http://blog.csdn.net/jcx5083761/article/details/9091701">http://blog.csdn.net/jcx5083761/article/details/9091701</a></p>

<h3>参考链接</h3>

<p>jquery api <a href="http://api.jquery.com/">http://api.jquery.com/</a></p>

<p>Web端我们有实时的JS报错监控平台<a href="https://github.com/tmallfe/tmallfe.github.io/issues/6">https://github.com/tmallfe/tmallfe.github.io/issues/6</a></p>

<p>js类继承<a href="http://javascript.crockford.com/zh/inheritance.html">http://javascript.crockford.com/zh/inheritance.html</a></p>

<h3>url玩法</h3>

<p><a href="http://www.cuplayer.com/player/PlayerCodeJS/2014/1218/1708.html">http://www.cuplayer.com/player/PlayerCodeJS/2014/1218/1708.html</a></p>

<h3>未消化</h3>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[js动态添加 from表单元素]]></title>
    <link href="http://mzkmzk.github.io/blog/2015/01/03/js_add_from/"/>
    <updated>2015-01-03T11:37:40+08:00</updated>
    <id>http://mzkmzk.github.io/blog/2015/01/03/js_add_from</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
</feed>
