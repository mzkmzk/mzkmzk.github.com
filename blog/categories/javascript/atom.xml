<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: javascript | K]]></title>
  <link href="http://mzkmzk.github.io/blog/categories/javascript/atom.xml" rel="self"/>
  <link href="http://mzkmzk.github.io/"/>
  <updated>2015-10-25T22:15:40+08:00</updated>
  <id>http://mzkmzk.github.io/</id>
  <author>
    <name><![CDATA[K]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[疯狂Html+CSS+JS 中JS总结]]></title>
    <link href="http://mzkmzk.github.io/blog/2015/10/05/amazeing-js/"/>
    <updated>2015-10-05T11:37:40+08:00</updated>
    <id>http://mzkmzk.github.io/blog/2015/10/05/amazeing-js</id>
    <content type="html"><![CDATA[<!--more-->


<h1>0 总结</h1>

<p>本书的JS</p>

<ol>
<li>第一章有讲语法有挺多常见的坑点和原理解释很不错</li>
<li>第二章DOM编程讲述了挺多API</li>
<li>第三章事件处理机制其实对事件中的this关键字和事件传播顺序讲解还不错</li>
<li>第四章WebStorage本地存储例子鲜明</li>
<li>第五章Worker应付复杂的js操作</li>
<li>第六章客户端通信WebSocket挺有用,可以实现用户与用户在浏览器中互动</li>
</ol>


<h1>1. JavaScript语法</h1>

<h2>1.1 执行js代码</h2>

<ol>
<li>javascript:alert(&lsquo;执行js&rsquo;);</li>
<li><code>&lt;script&gt;alert("执行js")&lt;/script&gt;</code></li>
</ol>


<h2>1.2 变量赋值</h2>

<pre><code>var a = 1;//显式
a =1; //隐式
</code></pre>

<h2>1.3 全局变量与局部变量</h2>

<pre><code>...
var scope = "全局变量";
function test(){
    alert(scope); // undefiend
    var scope = "局部变量";
    alert(scope); // 局部变量
}
</code></pre>

<p>因为全局变量被局部变量覆盖了.虽然局部变量的scope还没赋值,但是已经在方法里&#8221;占&#8221;上位置了.</p>

<p>但如果把局部变量的var删了,就会先输出全局变量后输出局部变量,因为没有var在方法里给局部变量&#8221;占&#8221;位置;</p>

<h2>1.4 浮点数</h2>

<pre><code>var a =.333
var b = a * 5;
alert(b);
</code></pre>

<p>得出的结果是 1.66499999999999999</p>

<p>所以在js中判断浮点数是否相等 建议判断两者的差值是否小于一个足够的数(例如0.0000000000001)</p>

<h2>1.5 字符串</h2>

<p>js中没有字符类型变量 &ldquo;&#8221;与&#8217;&lsquo;一致</p>

<pre><code>var s ="abcdefg"

//b = "def"
b = s.slice(3, -1);
</code></pre>

<h2>1.6 字符串的正则表达式方法中</h2>

<ol>
<li>match()返回匹配的字符串(数组或null),可加/g进行全局匹配多个</li>
<li>search()返回匹配的索引值 单个</li>
</ol>


<h2>1.7 undefined和null</h2>

<pre><code>null == undefined //true

null === undefined //false
</code></pre>

<p>undefined 是没设值</p>

<p>null则是设定了为null值</p>

<h2>1.8 运算符</h2>

<pre><code>//逗号运算符 取最右返回值
a = (b =5 , c = 7 , d =56) //a =56

a = void(b =5 , c = 7 , d =56) //a = undefined
</code></pre>

<h2>1.9 typeof和instanceof</h2>

<p>typeof 用来获得 实例类型 :</p>

<pre><code>typeof("123"); //string
</code></pre>

<p>instanceof 判断变量是否为某类的实例</p>

<pre><code>var a = [4,5];
alert(a instanceof Array); //true
</code></pre>

<h2>1.10 语句</h2>

<p>抛出异常</p>

<pre><code>throw new Error("用户自定义异常"); //一般用于终止程序和返回错误提示是个不错的选择;

try{

}catch(e){
    alert(e.message); // "用户自定义异常"
}
</code></pre>

<p>for in</p>

<pre><code>//这回输出浏览器的所有属性,做浏览器兼容之前可以考虑看看.
for( prop_name in navigator){
    document.wrti(prop_name + " : " + navigator[propname]);
}   
</code></pre>

<p>跳出命名for</p>

<pre><code>outer: 
for(...){
    for(...){
        ...
        continue outer;
    }
}
</code></pre>

<h2>1.11 函数</h2>

<p>js 允许先调用函数 再定义函数</p>

<h3>1.11.1 定义匿名函数</h3>

<pre><code>var show_name = function(name){
    alert(name);
}

show_name("K"); //K
</code></pre>

<p>这样的好处是什么,如果直接定义function 它实际上也是创建了一个对象</p>

<h3>1.11.2 函数既对象</h3>

<pre><code>var hello = function(){...};

hello instanceof Function //true;

hello instanceof Object //true;

alert(heelo) //输出函数源代码
</code></pre>

<h3>1.11.3 调用函数方式的不同</h3>

<ol>
<li>直接调用函数 返回return的值或void</li>
<li>new 函数 得到的都是对象 - -&hellip;&hellip;.</li>
</ol>


<h3>1.11.4 this关键字.</h3>

<p>在函数中使用this.变量 该变量就是函数的实例变量,而非局部变量,无论它在哪里.</p>

<p>函数可依附在类中.如没指定 则依附在winodw对象中</p>

<pre><code>var hello =function(){...}

window.hello();

var p = {
    wark: function(){...}
}
p.wark();
</code></pre>

<h3>1.11.5 函数中的变量有三种</h3>

<pre><code>function Person(){
    //局部变量 只能在函数里访问
    var id ;

    //实例属性 通过对象.访问
    this.age ;

    //类属性 通过Patient.name访问 与static类似
    Person.name ;
}
</code></pre>

<h3>1.11.6 js是一种动态语言,能随时给对象增加属性和方法</h3>

<pre><code>function Student(){ };

var student =new Student();
//动态增加name属性
student.name = 'K';
alert(sutdent.name) //K

Student.age =22 ;
alert(Student.age); //22 类属性也是可以动态添加的
</code></pre>

<h3>1.11.7 调用函数的三种方式</h3>

<ol>
<li><p>直接调用</p>

<pre><code> windows.alert();
 //or
 alert();
</code></pre></li>
<li><p>call()调用</p>

<p> 作用:动态地传入一个函数引用</p>

<pre><code> var each = function(array,fn){
     for(var index in arrary){
         //null表示以window为调用者fn函数
         fn.call(null,index,arrary[index]);
     }
 }

 each([4,20,3] , function(index ,ele){
     alert("第 " + index "个元素是 : " + ele);
 });
</code></pre>

<p> call()调用函数语法为:<code>函数引用.call(调用者,参数1,参数2...)</code></p>

<p> 直接调用函数语法为:<code>调用者.函数(参数1,参数2 ...)</code> = <code>函数.call(调用者,参数1,参数2 ...)</code></p></li>
<li><p>apply()调用</p>

<p> apply和()call()基本相似,区别如下:</p>

<ol>
<li>通过call()调用函数时,括号必须详细列出每个参数</li>
<li><p>通过apply()动态地调用函数时,可以在括号中以<code>arguments</code>来代表所有参数</p>

<pre><code> var myfun = function (a , b){
     alert(a + "  " +b);
 }

 myfun.call(window ,12 ,23); //12 23;

 myfun.apply(window ,[20 , 39]); //20 39

 var example = function (num1 ,num2){
     //直接调用arguments代表调用者(example,this代表example)时的传入的所有参数
     myfun.apply(this,arguments); 
 }
 example(20,40) //20 40 
</code></pre></li>
</ol>
</li>
</ol>


<h3>1.11.8 函数的独立性</h3>

<p>在函数A中可以定义函数B,但是函数B还是独立于函数A</p>

<pre><code>function Person(name){
    this.name = name;

    this.info = function(){
        alert(this.name);
    }
}   

var person =new Person('K');
person.info(); //K
var name = 'K_window';

//由于window为调用者 ,this.name访问的是window.name
p.info.call(window); //K_window
</code></pre>

<p>来爽一发猫学狗叫?.</p>

<pre><code>function Dog(name,bark){
    this.name = name;
    this.bark = bark;
    this.info =function(){
        alert(this.name + "  " + this.bark);
    }
}

function Cat(name){
    this.name =name;
}   

var dog = new Dog("K","汪汪!");
var cat = new Cat("K_2");
dog.info.call(cat); //K_2 undefined
</code></pre>

<h3>1.11.9 参数传递方式</h3>

<p>和JAVA一样 都是值传递拉~.</p>

<p>基本类型</p>

<pre><code>function change(arg){
    arg =10 ;
    alert(arg);
}
var x = 5;
alert(x); //5
change(x); //10
alert(x); //5
</code></pre>

<p>复合类型</p>

<pre><code>function change(person){
    person.age = 10;
    alert(person.age);
    person = null;
}

var person = {age : 5};
alert(person.age); //5
change(person); //10
alert(person.age); // 10
alert(person); // []object Object]
</code></pre>

<p>复合类型的传递为值传递,原person和参数person指向同一javascript对象,所以当改变age的时候,是在改变javascript对象的age,但是参数person赋值为null,原person并无改变.</p>

<h3>1.11.10 空参数</h3>

<pre><code>function text(person){
    alert( typeof parson);
}

text(); //undefined
</code></pre>

<p>所以对于弱类型,方法重载是无作用的,因为js会把空参数当做undefined传递进去;</p>

<p>同名函数,后面出现的会覆盖前面的,无论参数个数是多少.</p>

<h3>1.11.11 对象和关联数组</h3>

<p>javascript和Map有点类似,当key为对象,value为函数,该该函数就是对象的方法,当key为对象,value为基本类型,则该基本类型为对象的属性.(以上为便于理解,切勿细琢)所以访问属性时,可以obj.propName也可以obj[propName].</p>

<p>但有时候我们只能用obj[propName],因为.propName不能把propName当做变量处理,而是把他当成&#8217;propName&#8217;字符串</p>

<pre><code>function Person(name){
    this.name =name;
    this.info = function(){
        alert(K);
    }
}

var person = new Person("K");
//遍历person属性
for (propName in person){
    alert(p[propName]);//alet K info源代码 假如此处用p.propName则undefined,因为Person无'propName'变量.
}
</code></pre>

<h3>1.11.12 继承和prototype</h3>

<p>在一个类(函数)中定义一个函数会导致</p>

<ol>
<li>性能低下:每次new一个类 都会生成一个函数</li>
<li><p>函数中若引用类的局部变量会产生闭包 导致局部变量一直存在</p>

<pre><code> function Person(){
     var local = "局部变量"
     this.info = function(){
         //产生闭包
         alert(local);
     }
 }

 var person = new Person();
 person.ifno(); // 局部变量  
</code></pre></li>
</ol>


<p>解决方案:prototype</p>

<p>增加了prototype属性的类可视为继承了原先的类(伪继承)</p>

<pre><code>function Person(){...}

var person = new Person();

//person.wark(); 程序报错wark不存在
Person.prototype.wark = function(){...}

person.wark(); //ok
</code></pre>

<p>在prototype之前实例化的类会具有wark方法吗? 有的,因为prototype这样并不会产生一个新的类,而是直接动态的往Person里加函数.</p>

<h2>1.12 创建对象三种方式</h2>

<pre><code>//(单身汪别说我不教你)
</code></pre>

<ol>
<li><p>new关键字调用构造器创建对象</p>

<pre><code> function Person(name){...}
 var person_1 = new Person();
 var person_2 = new Person('K'); //js不存在方法重载,空参数undefined顶替
</code></pre></li>
<li><p>使用Object直接创建对象</p>

<pre><code> var my_obj = new Object();
 my_ojb.name = 'K';
 my_obj.handsome = function(){...}

 function text(){...}
 my_obj.text = text;//不要添加(),不然会认为是调用方法
</code></pre></li>
<li><p>JSON创建对象</p>

<pre><code> ver person = {
     name : 'K',
     school : ['ChangAn','TianJin'],
     girl_friends :[
         {
             name : 'Haski',
             age : 11
         },
         {
             name : 'Samoyed',
             age : '8'
         }
     ]
 }

 alert(person.girl_friends[0].name); //Haski
</code></pre></li>
</ol>


<h1>2 DOM编程</h1>

<p>DOM操作其实JQuery已经做得很好了,这里简单补充一下原生JS的知识</p>

<p>HTML文档中只有一个根节点</p>

<h2>2.1 访问HTML元素</h2>

<ol>
<li>id getElementById(&lsquo;id&rsquo;); or getElementsByName(&lsquo;name&rsquo;);</li>
<li><p>根据节点关系</p>

<pre><code> Node parentNode: 返回父节点
 Node previousSibling: 返回前一个兄弟节点
 Node nextSibling: 饭后后一个兄弟节点
 Node[] childNodes 返回当前节点的所有节点
 Node[] getElementsByTagName('标签名称'): 返回当前节点具有制定标签的子节点
 //注意ol标签的子标签IE8和其他浏览器不一样(其他浏览器会把ol下的li和其后面的空白分别当成2个节点,IE8则不会)
</code></pre></li>
</ol>


<h2>2.2 增加HTML函数</h2>

<ol>
<li>document.createElement(&ldquo;标签名&rdquo;);</li>
<li>复制节点 var node = ul.firstChild.nextSibling.cloneNode(boolean),boolean为true时,复制所有所有后代节点.false则仅复制当前节点.clone了节点以后还要找一个节点添加进去.</li>
</ol>


<h2>2.3 添加节点</h2>

<ol>
<li>appendChild(Node);添加为当前节点的最后一个子节点</li>
<li>inserBefore(newNode,refNode);在refNode前添加newNode</li>
<li>replaceChild(newChild,oldChild);替换节点</li>
<li>增加select选项 new Option(text,value,defaultSelected,selected);</li>
</ol>


<h2>2.4 删除节点</h2>

<ol>
<li>removeChild(oldNode);</li>
</ol>


<h2>2.5 window对象</h2>

<ol>
<li>返回上一个页面: back()</li>
<li>window.href: 当前url</li>
<li>window.width: 屏幕横向分辨率</li>
<li>window.height: 屏幕纵向分辨率</li>
<li><p>遍历window.screen,包含所以屏幕属性</p>

<pre><code> for(var propName in window.screen){
     alert(propName+":" +screent[propname]);
 }
</code></pre></li>
<li><p>cofrim(&lsquo;标题&rsquo;); 能弹出是否确认的提示框</p></li>
<li>prompt(&lsquo;标题&rsquo;); 能弹出一个文本输入框输入.</li>
<li><p>定时器:setInterVal,clearInterval()</p>

<pre><code> var timer;
 var cur = new Date().getTime();
 var setTime = function(){
     document.getElementById("tm").innerHTML = new Date().toLocationString();
     if(new Date().getTime- cur &gt; 60 *1000){
         clearInterval(timer);
     }
 }
 //每1S执行一次,执行了60次就暂停
 timer = window.setInterval("setTime()",1000);
</code></pre></li>
</ol>


<h2>2.6 navigator和地理位置</h2>

<p>navigator汉堡浏览器所有信息,遍历循环获取信息</p>

<pre><code>for(var propName in window.navigator){
    alert(propName + ":" + window.navigator[propName]);
}   
</code></pre>

<p>HTML5新增geolocation属性</p>

<p>Geolocation提供的方法</p>

<ol>
<li>getCurrentPosition(onSuccess,onError,options)</li>
<li>int watchCurrentPostion(OnSuccess,onError,options),周期性调用getCurrentPosition,返回的int代表这个&#8221;监听器&#8221;的ID,用来clearWatch(watchID)取消监听</li>
<li>clearWatch(watchID),用于取消watchCurrentPosition</li>
</ol>


<p>上面的前两个方法的options参数是一个对象,可包含3个变量</p>

<ol>
<li>enabelHighAccuracy(是否制定高精度地理位置)</li>
<li>tiemout 设置超时时长</li>
<li>maximumAge,设置缓存时间</li>
</ol>


<p>例子:</p>

<pre><code>var geoHandler = function(position){
    var geoMsg = "用户地址位置是 : &lt;br/&gt;"
    geoMsg += "timestamp属性为 :" + position.timestamp + "&lt;br/&gt;"//获取位置的时间
    var cords =position.coords;
    for(var prop in coords ){
        geoMsg += prop + ": " + coords[prop] +"&lt;br/&gt;"//经纬度,移动速度等
    }
    document.writeln(geoMsg);
}

var errorHandler = function(error){
    var errMsg = {
        1: '用户拒绝了位置服务'
        2: '无法获取地址位置信息'
        3: '获取地理位置信息超时'
    };
    alert(error[error.code]);
}

navigator.geolocation.getCurrentPosition(geoHandler
, errorHandler
, {
    enableHighAccuracy:true,
    maximuAge:1000
});
</code></pre>

<h2>2.7 HTML5新增浏览器分析</h2>

<p>实现该功能主要通过performance对象</p>

<p>其中的(PerformanceTiming)timing属性包含加载时间相关的属性</p>

<p>另外(PerformanceNavigation)navigation,主要属性有</p>

<p>type :</p>

<pre><code>TYPE_NAVIGATE(数值为0): 超链接/输入url
TYPE_RELOAD(1): 重新加载方式,diaoyonglocation.reload()等
TYPE_BACK_FORWARD(2): 通过浏览器的前进方式
TYPE_RESERVED(255): 未知方式
</code></pre>

<p>redirectCount: 重定向次数</p>

<h1>3 事件处理机制</h1>

<h2>3.1 常见事件</h2>

<ol>
<li>onabort: 图片加载终端</li>
<li>onblur: 失去焦点</li>
<li>onchange: 表单域更改</li>
<li>onclick: 点击</li>
<li>onerror: 图片加载出错</li>
<li>onfocus: 获得焦点</li>
<li>onkeydown: 按下鼠标</li>
<li>onkeypress: 当焦点在当前元素上,单击键盘某个键触发</li>
<li>onkeyup: 当焦点在当前元素上,松开某个键触发</li>
<li>onload: 某个对象加载完毕,适用于<code>img</code>,<code>oframe</code>,<code>body</code></li>
<li>onunload: 当某个对象从窗口下卸载触发,适用于<code>img</code>,<code>oframe</code>,<code>body</code></li>
<li>onmousedown: 焦点停留在当前元素上,按下鼠标触发</li>
<li>onmousemore: 当焦点在当前元素上,鼠标移动到该元素</li>
<li>onmouseout: 鼠标移出当前元素触发</li>
<li>onmouseover: 鼠标移动到该元素触发</li>
<li>onmouseup: 焦点在当前元素,松开鼠标时触发</li>
<li>onreset: 重置表单时触发</li>
<li>onsubmit: 表单提交触发</li>
</ol>


<h2>3.2 事件处理和this</h2>

<pre><code>p.info = function(){
    alert(this.name);
}
document.getElementById("bt").onclick = p.info//this指向'bt'控件
document.getElementById("bt").onclick = new function (){ p.info();} //this总是指向p
</code></pre>

<p>注意表单设置id为x和name为y时候,相当于表单创建了x属性和y属性,所以id和name不能是关键字submit等</p>

<h2>3.3 DOM</h2>

<p>创建监听事件</p>

<p>objectTarget.addEventListener(&ldquo;eventType&rdquo;,handler,capture),第一个参数表示绑定的事件,如click、keypress之类的,第二个制定绑定的函数,第3个位boolean,true表示监听捕获阶段,false表示监听冒泡阶段</p>

<p>objectTarget.removeEventListener(&ldquo;eventType&rdquo;,handler,captureFlag): 删除绑定事件</p>

<p>捕获状态阶段的绑定事件先执行,事件冒泡状态阶段的绑定事件后执行.
捕获状态阶段从外往内触发,事件冒泡状态阶段从内往外触发.</p>

<p>绑定例子</p>

<pre><code>var got_click = function (event){
    for ( event_one in event){
        alert(event_one + "  : " + event[event_one]);
    }
}   

document.getElementByID("test").addEventListener("cilck",got_click,true);
</code></pre>

<p>阻止事件传播</p>

<pre><code>event.stopPropagation();
</code></pre>

<p>取消事件的默认行为,如跳转页面等,但不会阻止事件传播.</p>

<pre><code>event.preventDefault();
</code></pre>

<h3>3.3.1转发事件</h3>

<p>DOM提供了dispathEvent方法用于事件转发,该方法属于Node</p>

<p>target.dispathEvent(Event event),将event转发到target上</p>

<p>DOM的dispath()必须转发人工合成的Event事件</p>

<p>document.createEvent(String type),tpy参数用于指定事件类型,eg:普通事件Events,UI事件UIEvents,鼠标事件:MouseEvents</p>

<p>初始化事件</p>

<pre><code>initEvent(具体参数...)

initUIEvent(具体参数...)

intMouseEvent(具体参数...)

//例子

&lt;input id="bt1"&gt;
&lt;input id="bt2"&gt;
...

var rd =function(evt){
    alert("事件冒泡阶段: " + evt.currentTarget.value +"被点击了");
    var e =document.createEvent("Evnets");
    e.initEvent("click",true,false);//true表示是否支持冒泡,false表示是否有默认行为
    document.getElementById("bn2").dispathEvent(e);
}
var go_click = function (evt){
    alert("事件冒泡阶段: " + evt.currentTarget.value);
}

document.getElementById("bn1").addEventListener("click",rd,false);

document.getElementById("bn2").addEventListener("click",go_click,false);;

//点解按钮一结果
alert(事件冒泡阶段: 按钮一被点击了);
alert(事件冒泡阶段:按钮2);
</code></pre>

<p>点击按钮1,按钮执行了前面按钮一被点击了提示语句后,将点击事件转给了按钮2,按钮2执行自身的点击事件.</p>

<h1>4 本地存储与离线应用</h1>

<h2>4.1 Web Storage</h2>

<p>使用理由之一Cookie的局限性:</p>

<ol>
<li>Cookie大小被限制为4KB</li>
<li>Cookie会包含在每次HTTP请求中</li>
<li>Cookie网络传输未加密(除非整个应用都使用SSL)</li>
</ol>


<p>Web Storage分两种</p>

<p>Session Storage: 生命周期与用户Session一致(用户Session是指:用户从访问网址到离开网址/关闭浏览器)</p>

<p>Local Storage: 保存在用户的磁盘中,失效的方式为用户/程序显示删除.</p>

<p>Web Storage的方法有</p>

<ol>
<li>length: 返回key-value对数</li>
<li>key(index): 返回第index个key</li>
<li>getItem(key): 获取key对应的value</li>
<li>set(key,value): 设置key-value</li>
<li>removeItem(key): 删除key-value</li>
<li>clear(): 清除所有key-value</li>
</ol>


<p>Web Storage包含在window对象中</p>

<p>当value为对象时,建议用JSON存储</p>

<h2>4.2 构建离线应用</h2>

<ol>
<li><p>在html标签中修改</p>

<pre><code> //表明该页使用index.manifest文件
 &lt;html manifest="index.manifest"&gt;
</code></pre></li>
<li><p>index.mainfest文件</p>

<pre><code> CACHE MANIFEST
 //第一行必须为上述字符
 //指定版本号
 #version 1
 //本地缓存资源
 CACHE
 inedx.html
 logo.jpg
 //不缓存的资源
 NETWORK
 *
 //前者表示在线状态使用的资源,后者代表离线状态使用的资源
 FALLBACK
 test.js offline.js
</code></pre></li>
<li><p>Tomcat为例,天津映射文件</p>

<pre><code> &lt;!--conf的web.xml根元素中增加MIME映射--&gt;
 &lt;mine-mapping&gt;
     &lt;extension&gt;manifest&lt;/extension&gt;
     &lt;mine-type&gt;text/cache-mainfest&lt;/mime-type&gt;
 &lt;/mime-mapping&gt;
</code></pre></li>
</ol>


<p>启动应用后,页面可刷新(即使离线状态),并使用离线时候的资源</p>

<h3>4.2.1 判断在线状态</h3>

<p>navigator.onLine属性: true表示在线</p>

<p>online/offline事件: 当在线/离线状态切换时,body上的online/offine事件会被触发,沿着document.body、document和window冒泡</p>

<pre><code>window.addEventListener("offline",function(){
    alert("离线状态")
},true);
if(navigator.onLine){
    alert("在线");
}
</code></pre>

<h3>4.2.2 applicationCache对象</h3>

<p>js可通过applicationCache控制离线缓存.</p>

<p>status属性:</p>

<ol>
<li>UNCACHE: 主机没开启离线功能.</li>
<li>IDLE: 空闲状态.</li>
<li>CHECKING: 正在检查本地manifest和服务器中manifest的差异</li>
<li>DOWNLOADING: 正在下载需要的缓存数据</li>
<li>OBSOLETE: 缓存已经过期</li>
</ol>


<p>常用方法</p>

<ol>
<li>void update(): 强制检查服务器的mainfest文件是否有更新</li>
<li><p>void swapCache(): 更新缓存,只能在applicationCache的updateReady事件被触发时调用.</p>

<pre><code> setInterval(function(){
     applicationCache.update()
 },2000);

 applicationCache.onupdateready = function(){
     if(confirm("已从远程服务器下载了需要的缓存,是否更新?")){
         applicationCache.swapCache();
         location.reload();
     }
 }
</code></pre>

<h3>4.2.3 离线应用的事件与监听</h3></li>
</ol>


<p>访问html页面过程</p>

<ol>
<li>浏览器请求index.html</li>
<li>服务器返回index.html</li>
<li>浏览器页面是否制定manifest属性,若制定,触发checking事件,检查服务器中的manifest文件是否存在,不存在则触发error事件,不会制定第六部及其后续步骤</li>
<li>浏览器解析index.html,请求该页其他资源.</li>
<li>服务器返回所以请求</li>
<li>浏览器处理mainfest文件,重新请求manifest文件中的所以页面,包括index.html页面,前面下载过的资源,扔会再下一遍.</li>
<li>服务器返回所以要求被要求缓存的资源</li>
<li>浏览器开始下载需要在本地缓存的资源,开始下载时触发ondownloading事件,在下载过程中不断触发onprogress事件.以便开发人员了解下载进度.</li>
<li>下载完成后触发oncache事件.缓存完成</li>
</ol>


<p>当用户再访问index.html时,前面1~5完全相同,接下来检测mainfest文件是否有改变.</p>

<ol>
<li>没有改变触发onnoupdate事件,结束.</li>
<li>mainfest改变,执行第7,8部,当所以文件本地缓存下载完毕后,浏览器触发onupdateready事件,而不会触发oncached事件.</li>
</ol>


<h1>5 使用worker创建多线程</h1>

<p>worker中无法使用DOM、alert等与界面有关的操作.</p>

<p>使用理由:防止js阻塞主线程的js运行</p>

<p>WorkerAPI</p>

<ol>
<li>onmessage: 获取前台js提交过来的数据</li>
<li>postMessage(data): 前台js通过postMessage触发Worker对象的onmessage事件.</li>
<li>importScripts(urls),导入多个js,importScripts(&ldquo;a.js&rdquo;,&ldquo;b.js&rdquo;);</li>
<li>sessionStorge/localStorage: 使用Worker操作Storage本地存储</li>
<li>Worker: 创建新的Worker对象启动嵌套线程</li>
<li>XMLHttpRequest: Worker使用XMLHttpRequest发送异步请求.</li>
<li>navigator: 与window的location属性类似</li>
<li>location: 与window的location属性相似</li>
<li>self: WorkerGlobalScope对象,代表当前Worker线程自身作用域.调用self的close()结束线程</li>
<li>setTimeout()/seInterval()/eval()/inNaN()/parseInt,等与界面无关的js核心函数,包括Array/Data/Math/Number/Object/String等.</li>
</ol>


<p>写一段找出输入start和end之间素数的线程.</p>

<p>worker.js代码</p>

<pre><code>onmessage =function(event){
    var data =JSON.parse(event.data);
    var start =data.start;
    var end =data.end;
    var result ="";
    search:
    for (var n =start; n &lt;= end :n++){
        if(n%i==0){
            continue search;
        }
        result +=(n+",");
    }
}
postMessage(result);
</code></pre>

<p>网页代码</p>

<pre><code>&lt;input name="start" ...&gt;
&lt;input name="end" ...&gt;
&lt;input type=button inclick="cal();" ...&gt;
...
var car =function(){
    var start = parseInt(document.getElementById("start").value);
    var end = parseInt(document.getElementById("end").value);
    //创建线程
    var cal = new Worker("worker.js");
    var data ={
        "start" : srart,
        "end" : end
    };
    //发送数据
    cal.postMessage(JSON.stringify(data));
    cal.onmessage = function (evnet){
        alert(event);
    }
}
</code></pre>

<p>并行的两条Worker不能互相通信,但Wroker可嵌套.</p>

<h1>6 客户端通信</h1>

<p>WebSocket: 服务器主动推送信息/客户端实时推送数据到服务器</p>

<h2>6.1 跨文档通信</h2>

<p>window对象新增方法</p>

<ol>
<li>targetWindow.postMessage(message,targetOrigin): 该方法用户向targetWindow中状态的HTML发送信息,targetOrigin表示接收html的域名.</li>
<li><p>onmessage: 调用方法:windows.onmessage =function(event){&hellip;}</p>

<p> event中的属性:</p>

<ol>
<li>data: 数据</li>
<li>orgin: 发送消息window的源域名</li>
<li>lastEventID: 返回发送消失时间的ID</li>
<li>source: 返回发送消息的窗口</li>
</ol>
</li>
</ol>


<p>html想发送要做</p>

<ol>
<li>获取接收消息的window对象</li>
<li>调用接收消息的window对象的postMessage(any message)方法</li>
</ol>


<p>html想接收要做</p>

<ol>
<li>本html绑定事件window.message = function(event){&hellip;};</li>
</ol>


<p>跨文档消息传递</p>

<pre><code>//source.html
var targetWin = window.open("接收方url",'_blank','windth=400,height=300');

targetWin.onload =function(){
    targetWin.postMessage("传输消息","接收方域名");
}

window.onmessage =function(event){
    //忽略其他域名发送的消息
    if(event.orgin !="指定域名"){
        return ;
    }
    alert(event.data);
}

//接收页面.html
window.onmessage = function(event){
    //忽略其他域名发送的消息
    if(event.orgin !="指定域名"){
        return ;
    }
    alert("接收到消息拉!"+event.data);
    event.source.postMessage("回传消息",event.origin);
}
</code></pre>

<p>结果:</p>

<p>alert(接收到消息拉!传输消息);</p>

<p>alert(回传消息);</p>

<p>注意!一定要判断发送方的域名!!!!!一定要判断发送方的域名!!!!!一定要判断发送方的域名!!!!!</p>

<h3>6.2 WebSocket与服务器通信</h3>

<p>以前方案:</p>

<ol>
<li>周期发送请求</li>
<li>页面使用隐藏窗口与服务器长连接</li>
</ol>


<p>WebSocket方法</p>

<ol>
<li>send(&ldquo;数据&rdquo;);向服务器发送数据.</li>
<li>close();关闭该WebSocket.</li>
</ol>


<p>WebSocket监听事件</p>

<ol>
<li>onopen: 当WebSocket建立网络连接触发该.</li>
<li>onerror: 网络连接错误</li>
<li>onclose: WebScokt被关闭触发</li>
<li>onmessage: WebSocket接收到服务器数据时</li>
</ol>


<p>WebSocket属性</p>

<ol>
<li><p>readyState</p>

<p> 1.1 CONNECTING(0): WebSocket正在尝试连接</p>

<p> 1.2 OPEN(1): 已经连接</p>

<p> 1.3 CLOSING(2): 正在关闭连接</p>

<p> 1.4 CLOSED(3): 已经关闭连接</p></li>
</ol>


<p>WebSocket与服务器通信步骤</p>

<ol>
<li>WebSocket.Constructor(url,[DOMString protocols]);创建WebSocket对象</li>
<li>发送信息: WebSocket对象的send()</li>
<li>接收信息: WebSocket对象的onmessage属性绑定函数;</li>
</ol>


<p>实现客户端多人聊天,JAVA为例</p>

<p>客户端代码:</p>

<pre><code>var web_socket =new WebSocket("ws://域名:端口");

web_socket.onopen =function(){
    web_socket.onmessage =function(event){
        document.getElementById('show').innerHTML += event.data +"&lt;/br&gt;"
    }
};

var sendMsg =function(val){
    var inputElement = document.getElementByID('msg');
    webSocket.send(inputElement.value);
    inputElement.value="";
}

...
</code></pre>

<p>服务端代码</p>

<pre><code>import java.io.*;
import java.net.*;
import java.nio.charset.Charset;
import java.security.MessageDigest;
import java.util.regex.*;
import java.util.*;
import sun.misc.BASE64Encoder;

public class ChatServer
{
    // 记录所有的客户端Soccket
    public static List&lt;Socket&gt; clientSockets
        = new ArrayList&lt;Socket&gt;();
public ChatServer()throws IOException
{
    // 创建ServerSocket，准备接受客户端连接
    ServerSocket ss = new ServerSocket(30000);
    while(true)
    {
        // 接收到客户端连接
        Socket socket = ss.accept();
        // 将客户端Socket添加到clientSockets集合中
        clientSockets.add(socket);
        // 启动线程
        new ServerThread(socket).start();
    }
}
public static void main(String[] args)
    throws Exception{
    new ChatServer();
}
}
class ServerThread extends Thread
{
    private Socket socket;
    public ServerThread(Socket socket)
    {
        this.socket = socket;
    }
    public void run()
    {
    try
    {
        // 得到Socket对应的输入流
        InputStream in = socket.getInputStream();
        // 得到Socket对应的输出流
        OutputStream out = socket.getOutputStream();
        byte[] buff = new byte[1024];
        String req = "";
        // 读取数据，此时建立与WebSocket的"握手"。
        int count = in.read(buff);
        // 如果读取的数据长度大于0
        if(count &gt; 0)
        {
            // 将读取的数据转化为字符串
            req = new String(buff , 0 , count);
            System.out.println("握手请求：" + req);
            // 获取WebSocket的key
            String secKey = getSecWebSocketKey(req);
            System.out.println("secKey = " + secKey);
            String response = "HTTP/1.1 101 Switching Protocols\r\nUpgrade: "
                + "websocket\r\nConnection: Upgrade\r\nSec-WebSocket-Accept: "
                    + getSecWebSocketAccept(secKey) + "\r\n\r\n";
            System.out.println("secAccept = " + getSecWebSocketAccept(secKey));
            out.write(response.getBytes());
        }
        int hasRead = 0;
        // 不断读取WebSocket发送过来的数据
        while((hasRead = in.read(buff)) &gt; 0){
            System.out.println("接收的字节数：" + hasRead);
            /*
                因为WebSocket发送过来的数据遵循了一定的协议格式，
                其中第3个〜第6个字节是数据掩码。
                从第7个字节开始才是真正的有效数据。
                因此程序使用第3个〜第6个字节对后面的数据进行了处理
            */
            for (int i = 0 ; i &lt; hasRead - 6 ; i++ ){
                buff[i + 6] = (byte) (buff[i % 4 + 2] ^ buff[i + 6]);
            }
            // 获得从浏览器发送过来的数据
            String pushMsg = new String(buff
                , 6 , hasRead - 6 , "UTF-8");
            // 遍历Socket集合，依次向每个Socket发送数据
            for (Iterator&lt;Socket&gt; it = ChatServer.clientSockets.iterator()
                ; it.hasNext() ;)
            {
                try
                {
                    Socket s = it.next();
                    // 发送数据时，第一个字节必须与读到的第一个字节相同
                    byte[] pushHead = new byte[2];
                    pushHead[0] = buff[0];
                    // 发送数据时，第二个字节记录发送数据的长度
                    pushHead[1] = (byte) pushMsg.getBytes("UTF-8").length;
                    // 发送前两个字节
                    s.getOutputStream().write(pushHead);
                    // 发送有效数据
                    s.getOutputStream().write(pushMsg.getBytes("UTF-8"));
                }
                catch (SocketException ex)
                {
                    // 如果捕捉到异常，表明该Socket已经关闭
                    // 将该Socket从Socket集合中删除
                    it.remove();
                }
            }
        }
    }
    catch (Exception e)
    {
        e.printStackTrace();
    }
    finally
    {
        try
        {
            // 关闭Socket
            socket.close();
        }
        catch (IOException ex)
        {
            ex.printStackTrace();
        }
    }
}
// 获取WebSocket请求的SecKey
private String getSecWebSocketKey(String req)
{
    //构建正则表达式，获取Sec-WebSocket-Key: 后面的内容
    Pattern p = Pattern.compile("^(Sec-WebSocket-Key:).+",
            Pattern.CASE_INSENSITIVE | Pattern.MULTILINE);
    Matcher m = p.matcher(req);
    if (m.find())
    {
        // 提取Sec-WebSocket-Key
        String foundstring = m.group();
        return foundstring.split(":")[1].trim();
    }
    else
    {
        return null;
    }
}
// 根据WebSocket请求的SecKey计算SecAccept
private String getSecWebSocketAccept(String key)
    throws Exception
{
    String guid = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11";
    key += guid;
    MessageDigest md = MessageDigest.getInstance("SHA-1");
    md.update(key.getBytes("ISO-8859-1") , 0 , key.length());
    byte[] sha1Hash = md.digest();
    BASE64Encoder encoder = new BASE64Encoder();
    return encoder.encode(sha1Hash);
}
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[js 坑点]]></title>
    <link href="http://mzkmzk.github.io/blog/2015/09/21/js_error/"/>
    <updated>2015-09-21T11:37:40+08:00</updated>
    <id>http://mzkmzk.github.io/blog/2015/09/21/js_error</id>
    <content type="html"><![CDATA[<h1>未解决</h1>

<p>莫名其妙.在div中设置onclick方法就能找该方法,在包含下的input下就找不到.</p>

<pre><code>'&lt;div class="col-sm-1" onclick="delete_library()"&gt;'+
        '&lt;input  onclick="delete_library()" class="btn btn-info" id="delete_library_'+new_library_num+'" name="delete_library" value="删除"   style="width:100%"  /&gt;'+    
    '&lt;/div&gt;';
</code></pre>

<h1>已解决</h1>

<ol>
<li>jquery的ajax中不能再方法内return,返回的都是undefinte;</li>
<li>js加减乘除中运用在浮点数会不准确,需要另写方法,参考<a href="http://segmentfault.com/a/1190000000324193">http://segmentfault.com/a/1190000000324193</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用jQuery MiniUI搭建后台demo]]></title>
    <link href="http://mzkmzk.github.io/blog/2015/03/28/jquery_miniui/"/>
    <updated>2015-03-28T11:37:40+08:00</updated>
    <id>http://mzkmzk.github.io/blog/2015/03/28/jquery_miniui</id>
    <content type="html"><![CDATA[<p>jQuery MiniUI 提供了一套.net/php/java 的后台模板 这里介绍一下使用方法</p>

<h3>0x00下载demo</h3>

<p><a href="http://www.miniui.com/download/">http://www.miniui.com/download/</a></p>

<p>在这里选择使用的语言</p>

<h3>0x01导入demo</h3>

<h4>java</h4>

<p>在Eclipse导入<code>import-&gt;Existing Project</code>以后</p>

<p>项目会出现小红叉</p>

<p>解决办法:</p>

<p>删除不存在的jre
<code>右击项目-&gt;Bulid path-&gt;选中Libraries标签页-&gt;选中有小红叉的JRE -&gt;remove</code></p>

<p>导入本地的jre
<code>Add Library-&gt;Jre System Library-&gt;OK</code></p>

<p>如果此时项目中WebContent文件中有jsp报错 则Close项目 然后再Open</p>

<p>修改src中的TestDB.java中的相关数据库信息</p>

<h4>php</h4>

<p>把项目扔进apache的目录即可</p>

<p>然后在demo/data/invoke.php，修改相关数据库配置字符串。</p>

<h4>导入mysql数据库</h4>

<p>下载的项目中的WebContet中有个dbsql</p>

<p>如果导入.sql文件不存在..说数据库已存在 则</p>

<p>打开.sql文件 注释创建数据库的代码行</p>

<pre><code>#CREATE DATABASE `plusoft_test`
#CHARACTER SET 'utf8'
#COLLATE 'utf8_general_ci';

#USE `plusoft_test`;    
</code></pre>

<p>ok 运行项目即可</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[js 函数累积]]></title>
    <link href="http://mzkmzk.github.io/blog/2015/01/07/js_function/"/>
    <updated>2015-01-07T11:37:40+08:00</updated>
    <id>http://mzkmzk.github.io/blog/2015/01/07/js_function</id>
    <content type="html"><![CDATA[<p>jquery api<a href="http://jquery.bootcss.com/">http://jquery.bootcss.com/</a></p>

<h3>小函数</h3>

<ol>
<li>基本类型转换: parstFlat,parstInt等</li>
<li></li>
</ol>


<h3>select 选中项</h3>

<pre><code>设置select中value="paraValue"的Item为选中    
document.all.objSelect.value = objItemValue;  
</code></pre>

<p>参考链接<a href="http://www.cnblogs.com/Herist/archive/2007/09/24/903890.html">http://www.cnblogs.com/Herist/archive/2007/09/24/903890.html</a></p>

<h3>Dom元素加载完毕后调用方法 ready()</h3>

<pre><code>$(document).ready(function(){
    $(".btn1").click(function(){
        $("p").slideToggle();
    });
});
</code></pre>

<p>参考链接<a href="http://www.w3school.com.cn/jquery/event_ready.asp">http://www.w3school.com.cn/jquery/event_ready.asp</a></p>

<h3>jquery 控制css</h3>

<p>通过控制class为button_left的鼠标移入动作把id为up_page设置为可见</p>

<pre><code>$(".button_left").mouseover(function(){
$("#up_page").css("visibility","visible");
});
</code></pre>

<h3>js动态添加 from表单元素</h3>

<pre><code>//from_this参数作用为Onsubmit事件传递过来的from表单 或者通过id获取也可以
function  inser_Submit(from_this){
     var NFC_ID=document.createElement("input");
     NFC_ID.type="hidden";
     NFC_ID.name="NFC_ID";
     NFC_ID.value=document.getElementById("NFCID").value;
     from_this.appendChild(NFC_ID);
}   
</code></pre>

<h3>js设置cookie</h3>

<pre><code>document.cookie="key=value; path=/"
</code></pre>

<h3>form表单动态添加子成员</h3>

<pre><code>var page_form =document.createElement("form");
page_form.appendChild(document.getElementById("search_type"));
page_form.appendChild(document.getElementById("search_cancer_type"));
page_form.appendChild(document.getElementById("search_info"));
</code></pre>

<h3>函数积累</h3>

<ol>
<li>.trim();</li>
<li>window.location.href获取当前url</li>
<li>parseInt(String) Stirng转int</li>
<li>string.split(&lsquo;string_split&rsquo;) 方法用于把一个字符串分割成字符串数组。</li>
</ol>


<h3>jqeury函数积累</h3>

<ol>
<li>addClass(&ldquo;class&rdquo;); removeClass(&ldquo;class&rdquo;); 切换class:toggleClass(&ldquo;class&rdquo;);</li>
<li>获取内容.html(); 设置内容.html(&ldquo;内容&rdquo;);</li>
<li>$(document).ready(function(){});document加载完后执行的函数</li>
</ol>


<h3>注意点</h3>

<ol>
<li>用js提交form表单时,最好用get方法,因为用post方法的话,返回上一页需要重新提交表单.</li>
<li>jQuery的show()和hide()函数时,注意如果该空间不需要提交到form内,要<code>$("#id").attr("disabled",true);</code></li>
</ol>


<h3>js验证身份证</h3>

<pre><code>function IdentityCodeValid(code) {
    var city = {
        11: "北京",
        12: "天津",
        13: "河北",
        14: "山西",
        15: "内蒙古",
        21: "辽宁",
        22: "吉林",
        23: "黑龙江 ",
        31: "上海",
        32: "江苏",
        33: "浙江",
        34: "安徽",
        35: "福建",
        36: "江西",
        37: "山东",
        41: "河南",
        42: "湖北 ",
        43: "湖南",
        44: "广东",
        45: "广西",
        46: "海南",
        50: "重庆",
        51: "四川",
        52: "贵州",
        53: "云南",
        54: "西藏 ",
        61: "陕西",
        62: "甘肃",
        63: "青海",
        64: "宁夏",
        65: "新疆",
        71: "台湾",
        81: "香港",
        82: "澳门",
        91: "国外 "
    };
    var tip = "";
    var pass = true;

    if (!city[code.substr(0, 2)]) {
        tip = "身份证地址编码错误";
        pass = false;
    } else {
        //18位身份证需要验证最后一位校验位
        if (code.length == 18) {
            code = code.split('');
            //∑(ai×Wi)(mod 11)
            //加权因子
            var factor = [7, 9, 10, 5, 8, 4, 2, 1, 6, 3, 7, 9, 10, 5, 8, 4, 2];
            //校验位
            var parity = [1, 0, 'X', 9, 8, 7, 6, 5, 4, 3, 2];
            var sum = 0;
            var ai = 0;
            var wi = 0;
            for (var i = 0; i &lt; 17; i++) {
                ai = code[i];
                wi = factor[i];
                sum += ai * wi;
            }
            var last = parity[sum % 11];
            if (parity[sum % 11] != code[17]) {
                tip = "身份证校验位错误";
                pass = false;
            }
        }
    }
    if (!pass) alert(tip);
    return pass;
}
</code></pre>

<h3>操作json</h3>

<ol>
<li>向一个元素添加属性<code>json[i].key=value</code>;</li>
<li>json转为String<code>JSON.stringify()</code>参考链接<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify</a></li>
<li><p>json新增元素</p>

<pre><code> var title_x = [];
 var key = { "key" : value };
 title_x.push(key);
</code></pre></li>
<li><p>json排序<a href="http://www.cnblogs.com/breakdown/archive/2012/08/03/2619480.html">http://www.cnblogs.com/breakdown/archive/2012/08/03/2619480.html</a></p></li>
</ol>


<p>参考链接<a href="http://blog.csdn.net/jcx5083761/article/details/9091701">http://blog.csdn.net/jcx5083761/article/details/9091701</a></p>

<h3>参考链接</h3>

<p>jquery api <a href="http://api.jquery.com/">http://api.jquery.com/</a></p>

<p>Web端我们有实时的JS报错监控平台<a href="https://github.com/tmallfe/tmallfe.github.io/issues/6">https://github.com/tmallfe/tmallfe.github.io/issues/6</a></p>

<p>js类继承<a href="http://javascript.crockford.com/zh/inheritance.html">http://javascript.crockford.com/zh/inheritance.html</a></p>

<h3>url玩法</h3>

<p><a href="http://www.cuplayer.com/player/PlayerCodeJS/2014/1218/1708.html">http://www.cuplayer.com/player/PlayerCodeJS/2014/1218/1708.html</a></p>

<h3>未消化</h3>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[js动态添加 from表单元素]]></title>
    <link href="http://mzkmzk.github.io/blog/2015/01/03/js_add_from/"/>
    <updated>2015-01-03T11:37:40+08:00</updated>
    <id>http://mzkmzk.github.io/blog/2015/01/03/js_add_from</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
</feed>
